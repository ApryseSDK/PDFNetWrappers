<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>PDFTron PDFNet API Reference C++ API</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="pdftron_resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); fixDoxygen();});
</script>
<link href="https://fonts.googleapis.com/css?family=Lato:400,700&display=swap&subset=latin-ext" rel="stylesheet">
<link href="pdftron_doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table style="width:100%;" cellspacing="0" cellpadding="0">
    <tbody>
        <tr class="logorow">
            <td id="projectlogo">
                <a href="http://www.pdftron.com/">
                    <img alt="Logo" src="banner_logo.svg"/>
                </a>
            </td>
        </tr>
    </tbody>
</table>
</div><!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pdftron::SDF::SDFDoc Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_s_d_f_doc_8h_source.html">SDFDoc.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5b3783848b2580a6711beef4b2e2d5cc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a5b3783848b2580a6711beef4b2e2d5cc">SaveOptions</a> { <br/>
&#160;&#160;<a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a5b3783848b2580a6711beef4b2e2d5cca3adf8994ba8b0ba9a831142ffa34412f">e_incremental</a> = 0x01, 
<a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a5b3783848b2580a6711beef4b2e2d5ccadf55689d755e830879b1c57a4d9d1001">e_remove_unused</a> = 0x02, 
<a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a5b3783848b2580a6711beef4b2e2d5cca52b5a09e45ebf126476d2827c647e8bd">e_hex_strings</a> = 0x04, 
<a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a5b3783848b2580a6711beef4b2e2d5cca4903a0d9770323a5932a67e92c661265">e_omit_xref</a> = 0x08, 
<br/>
&#160;&#160;<a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a5b3783848b2580a6711beef4b2e2d5cca594319c7a980e2bbcf209276a2c7b629">e_linearized</a> = 0x10, 
<a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a5b3783848b2580a6711beef4b2e2d5cca90b577a908d149c2c6b0a7e82702ecf0">e_compatibility</a> = 0x20
<br/>
 }</td></tr>
<tr class="separator:a5b3783848b2580a6711beef4b2e2d5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abced5952169a6146ab95d5aa9e4145ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#abced5952169a6146ab95d5aa9e4145ca">SDFDoc</a> ()</td></tr>
<tr class="separator:abced5952169a6146ab95d5aa9e4145ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2169401d12cfd4abd58c009c5017e17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#aa2169401d12cfd4abd58c009c5017e17">SDFDoc</a> (const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;filepath)</td></tr>
<tr class="separator:aa2169401d12cfd4abd58c009c5017e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1415207c1b124a68738b6df71a94eb90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a1415207c1b124a68738b6df71a94eb90">SDFDoc</a> (const char *filepath)</td></tr>
<tr class="separator:a1415207c1b124a68738b6df71a94eb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921cb7e648b32295172f83dcf0d14de3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a921cb7e648b32295172f83dcf0d14de3">SDFDoc</a> (<a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a> stream)</td></tr>
<tr class="separator:a921cb7e648b32295172f83dcf0d14de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058219b827a8d3f1dd3330268f240f1a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a058219b827a8d3f1dd3330268f240f1a">SDFDoc</a> (unsigned char *buf, size_t buf_size)</td></tr>
<tr class="separator:a058219b827a8d3f1dd3330268f240f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4316bf4a405ec4876c000fd3d1ce09af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a4316bf4a405ec4876c000fd3d1ce09af">~SDFDoc</a> ()</td></tr>
<tr class="separator:a4316bf4a405ec4876c000fd3d1ce09af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81712a6723ba9dcae984dbe4aadb1955"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a81712a6723ba9dcae984dbe4aadb1955">Close</a> ()</td></tr>
<tr class="separator:a81712a6723ba9dcae984dbe4aadb1955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0d530e9b69297ef2814ad015e5da61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a3c0d530e9b69297ef2814ad015e5da61">IsEncrypted</a> ()</td></tr>
<tr class="separator:a3c0d530e9b69297ef2814ad015e5da61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50da682d96065666c6d0de5ffe9aef99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a50da682d96065666c6d0de5ffe9aef99">InitSecurityHandler</a> (void *custom_data=0)</td></tr>
<tr class="separator:a50da682d96065666c6d0de5ffe9aef99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3322f357d399a7ee4d19ba630fe0a5f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a3322f357d399a7ee4d19ba630fe0a5f4">InitStdSecurityHandler</a> (const char *password, int password_sz)</td></tr>
<tr class="separator:a3322f357d399a7ee4d19ba630fe0a5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e40581c13dfd2368d6a27d19a7d2d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a70e40581c13dfd2368d6a27d19a7d2d4">InitStdSecurityHandler</a> (const <a class="el" href="classpdftron_1_1_u_string.html">pdftron::UString</a> &amp;password)</td></tr>
<tr class="separator:a70e40581c13dfd2368d6a27d19a7d2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f6c0769e5b109feb9d67ad8ec38521"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a60f6c0769e5b109feb9d67ad8ec38521">InitStdSecurityHandler</a> (const std::vector&lt; <a class="el" href="namespacepdftron.html#a2538e0861ab3366a3bfab3665d0cd137">UInt8</a> &gt; &amp;password_buf)</td></tr>
<tr class="separator:a60f6c0769e5b109feb9d67ad8ec38521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ff2e516c0db3b24b7555dfdb1d0637"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#ab2ff2e516c0db3b24b7555dfdb1d0637">IsModified</a> () const </td></tr>
<tr class="separator:ab2ff2e516c0db3b24b7555dfdb1d0637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325c16e6051b56e37298779efb8ae001"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a325c16e6051b56e37298779efb8ae001">HasRepairedXRef</a> () const </td></tr>
<tr class="separator:a325c16e6051b56e37298779efb8ae001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16df7a03d92aa721e5e3f42436b07f70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a16df7a03d92aa721e5e3f42436b07f70">IsFullSaveRequired</a> () const </td></tr>
<tr class="separator:a16df7a03d92aa721e5e3f42436b07f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8825fba1daa3683495bae7491384e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a1b8825fba1daa3683495bae7491384e9">GetTrailer</a> ()</td></tr>
<tr class="separator:a1b8825fba1daa3683495bae7491384e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d4f39e28e6700b6b4f67500c2fca2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#ae7d4f39e28e6700b6b4f67500c2fca2e">GetObj</a> (const <a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a> obj_num) const </td></tr>
<tr class="separator:ae7d4f39e28e6700b6b4f67500c2fca2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de0a926d1127e509317f067e98e9a69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a4de0a926d1127e509317f067e98e9a69">ImportObj</a> (<a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> obj, bool deep_copy)</td></tr>
<tr class="separator:a4de0a926d1127e509317f067e98e9a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de5fbb7fc6910e8b0bc07ebcdda1af4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a4de5fbb7fc6910e8b0bc07ebcdda1af4">ImportObjs</a> (const std::vector&lt; <a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> &gt; &amp;obj_list)</td></tr>
<tr class="separator:a4de5fbb7fc6910e8b0bc07ebcdda1af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad655d5226067b50270373e0236f67617"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#ad655d5226067b50270373e0236f67617">ImportObjs</a> (const std::vector&lt; <a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> &gt; &amp;obj_list, const std::vector&lt; <a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> &gt; &amp;exclude_list)</td></tr>
<tr class="separator:ad655d5226067b50270373e0236f67617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79b6ec7237971730d314d1906f8269e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#ae79b6ec7237971730d314d1906f8269e">XRefSize</a> () const </td></tr>
<tr class="separator:ae79b6ec7237971730d314d1906f8269e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad603a40259f0f7c965794719daa3d353"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#ad603a40259f0f7c965794719daa3d353">ClearMarks</a> ()</td></tr>
<tr class="separator:ad603a40259f0f7c965794719daa3d353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29938306ef2e231dbc978ac525a215fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a29938306ef2e231dbc978ac525a215fe">Save</a> (const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;path, <a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a> flags, Common::ProgressMonitor *progress, const char *header)</td></tr>
<tr class="separator:a29938306ef2e231dbc978ac525a215fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7dbf76f70b53357569ed3c6c86a9c39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#aa7dbf76f70b53357569ed3c6c86a9c39">Save</a> (const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;path, <a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a> flags, const char *header)</td></tr>
<tr class="separator:aa7dbf76f70b53357569ed3c6c86a9c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144c773265eabc529fb1b5a2960063e3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a144c773265eabc529fb1b5a2960063e3">Save</a> (<a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a> flags, const char *header)</td></tr>
<tr class="separator:a144c773265eabc529fb1b5a2960063e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1e3919ca0b8af6aafae3f8ce548571"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a9a1e3919ca0b8af6aafae3f8ce548571">Save</a> (const char *&amp;out_buf, size_t &amp;out_buf_size, <a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a> flags, Common::ProgressMonitor *progress, const char *header)</td></tr>
<tr class="separator:a9a1e3919ca0b8af6aafae3f8ce548571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1951756a421770eea970606919e44a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#add1951756a421770eea970606919e44a">Save</a> (<a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a> stream, <a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a> flags, const char *header)</td></tr>
<tr class="separator:add1951756a421770eea970606919e44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc503d84cda3e38d758441e5a1baa36"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a3dc503d84cda3e38d758441e5a1baa36">GetHeader</a> () const </td></tr>
<tr class="separator:a3dc503d84cda3e38d758441e5a1baa36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17034c03a891fae0c9124c31e8b0cfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_security_handler.html">SecurityHandler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#ad17034c03a891fae0c9124c31e8b0cfa">GetSecurityHandler</a> ()</td></tr>
<tr class="separator:ad17034c03a891fae0c9124c31e8b0cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415ee38c8e7e7f2042700acfad753e23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a415ee38c8e7e7f2042700acfad753e23">SetSecurityHandler</a> (<a class="el" href="classpdftron_1_1_s_d_f_1_1_security_handler.html">SecurityHandler</a> handler)</td></tr>
<tr class="separator:a415ee38c8e7e7f2042700acfad753e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87c650027636e24f9aa9d73f5dccfbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#ad87c650027636e24f9aa9d73f5dccfbb">RemoveSecurity</a> ()</td></tr>
<tr class="separator:ad87c650027636e24f9aa9d73f5dccfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cdc09ebee857d2d83e499cffd79af4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#ad8cdc09ebee857d2d83e499cffd79af4">Swap</a> (<a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a> obj_num1, <a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a> obj_num2)</td></tr>
<tr class="separator:ad8cdc09ebee857d2d83e499cffd79af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987871e22fa1bb1c529008a413b7d6ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a987871e22fa1bb1c529008a413b7d6ca">CreateIndirectName</a> (const char *name)</td></tr>
<tr class="separator:a987871e22fa1bb1c529008a413b7d6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f453028bf1389d8727139626a43d85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a29f453028bf1389d8727139626a43d85">CreateIndirectArray</a> ()</td></tr>
<tr class="separator:a29f453028bf1389d8727139626a43d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fd478cd346ba86a7b39a41995c801f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a79fd478cd346ba86a7b39a41995c801f">CreateIndirectBool</a> (bool value)</td></tr>
<tr class="separator:a79fd478cd346ba86a7b39a41995c801f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e93bc9e2ba27341e8ad641524dd4f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a32e93bc9e2ba27341e8ad641524dd4f1">CreateIndirectDict</a> ()</td></tr>
<tr class="separator:a32e93bc9e2ba27341e8ad641524dd4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525f114e74d79df33fe5ec9ee6328095"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a525f114e74d79df33fe5ec9ee6328095">CreateIndirectNull</a> ()</td></tr>
<tr class="separator:a525f114e74d79df33fe5ec9ee6328095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a2ae1b8e27dc1795b0653de3bdf1b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#ae4a2ae1b8e27dc1795b0653de3bdf1b9">CreateIndirectNumber</a> (double value)</td></tr>
<tr class="separator:ae4a2ae1b8e27dc1795b0653de3bdf1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9843fede02ea3af760c62cacda9e26e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a9843fede02ea3af760c62cacda9e26e5">CreateIndirectString</a> (const <a class="el" href="namespacepdftron.html#a7bc90caf17b633a6832ec1e5162e1bc0">UChar</a> *value, <a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a> size)</td></tr>
<tr class="separator:a9843fede02ea3af760c62cacda9e26e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e4b91cf02326157b6aa995dbbdeda7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#ab4e4b91cf02326157b6aa995dbbdeda7">CreateIndirectString</a> (const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;str)</td></tr>
<tr class="separator:ab4e4b91cf02326157b6aa995dbbdeda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c1007b29e9f9c66b74c83abf274d50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#ad2c1007b29e9f9c66b74c83abf274d50">CreateIndirectStream</a> (<a class="el" href="classpdftron_1_1_filters_1_1_filter_reader.html">Filters::FilterReader</a> &amp;data, <a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a> filter_chain=<a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a>())</td></tr>
<tr class="separator:ad2c1007b29e9f9c66b74c83abf274d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea6820cd9698c7c0e9766a7ca4f815c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#aaea6820cd9698c7c0e9766a7ca4f815c">CreateIndirectStream</a> (const char *data, const size_t data_size, <a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a> filter_chain=<a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a>())</td></tr>
<tr class="separator:aaea6820cd9698c7c0e9766a7ca4f815c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbfcfe763d0f164c71f49cc6df0b3e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#abfbfcfe763d0f164c71f49cc6df0b3e7">IsLinearized</a> () const </td></tr>
<tr class="separator:abfbfcfe763d0f164c71f49cc6df0b3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bcdcd13f8ad39ac93d3f435fccbade"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#ac4bcdcd13f8ad39ac93d3f435fccbade">GetLinearizationDict</a> () const </td></tr>
<tr class="separator:ac4bcdcd13f8ad39ac93d3f435fccbade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c66e3dbe041e987f0b50c07a4ec4cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a35c66e3dbe041e987f0b50c07a4ec4cf">GetHintStream</a> () const </td></tr>
<tr class="separator:a35c66e3dbe041e987f0b50c07a4ec4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d916a8e9c29f757f6f3d6d7dcb0bad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a34d916a8e9c29f757f6f3d6d7dcb0bad">Lock</a> ()</td></tr>
<tr class="separator:a34d916a8e9c29f757f6f3d6d7dcb0bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273e72802115c890d80928a4337ad253"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a273e72802115c890d80928a4337ad253">Unlock</a> ()</td></tr>
<tr class="separator:a273e72802115c890d80928a4337ad253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05a56219ad2c9e8b9d9970873484bf5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#ac05a56219ad2c9e8b9d9970873484bf5">TryLock</a> (int milliseconds=0)</td></tr>
<tr class="separator:ac05a56219ad2c9e8b9d9970873484bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3735bb11b7d2ec7ed52a22d5ac29e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#adb3735bb11b7d2ec7ed52a22d5ac29e2">LockRead</a> ()</td></tr>
<tr class="separator:adb3735bb11b7d2ec7ed52a22d5ac29e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16489888bfaa12ae2e08678f2d32dbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#ad16489888bfaa12ae2e08678f2d32dbe">UnlockRead</a> ()</td></tr>
<tr class="separator:ad16489888bfaa12ae2e08678f2d32dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577ac29335caa15cba553c6ec565aed9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a577ac29335caa15cba553c6ec565aed9">TryLockRead</a> (int milliseconds=0)</td></tr>
<tr class="separator:a577ac29335caa15cba553c6ec565aed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6596cd267a7978cff33af3b50df0d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a5e6596cd267a7978cff33af3b50df0d3">GetFileName</a> () const </td></tr>
<tr class="separator:a5e6596cd267a7978cff33af3b50df0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a22fa5547a1ae2e8208ab023bc7809f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a0a22fa5547a1ae2e8208ab023bc7809f">EnableDiskCaching</a> (bool use_cache_flag)</td></tr>
<tr class="separator:a0a22fa5547a1ae2e8208ab023bc7809f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6572ab30f59e1670bbff1f5aa24b3ae8"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a6572ab30f59e1670bbff1f5aa24b3ae8">GetHandleInternal</a> ()</td></tr>
<tr class="separator:a6572ab30f59e1670bbff1f5aa24b3ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adab10e902c3a4f83fe1c468beb7409dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDFDoc</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#adab10e902c3a4f83fe1c468beb7409dc">CreateInternal</a> (ptrdiff_t impl)</td></tr>
<tr class="separator:adab10e902c3a4f83fe1c468beb7409dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDFDoc</a> is a low-level document representing a graph of <a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> nodes that can be used to build higher-level document models such as <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> (Portable Document Format) or <a class="el" href="namespacepdftron_1_1_f_d_f.html">FDF</a> (Forms Document Format).</p>
<p><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDFDoc</a> brings together document security, document utility methods, and all <a class="el" href="namespacepdftron_1_1_s_d_f.html">SDF</a> objects.</p>
<p>A <a class="el" href="namespacepdftron_1_1_s_d_f.html">SDF</a> document can be created from scratch using a default constructor:</p>
<p><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDFDoc</a> mydoc; <a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> trailer = mydoc.GetTrailer();</p>
<p><a class="el" href="namespacepdftron_1_1_s_d_f.html">SDF</a> document can be also created from an existing file (e.g. an external <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> document): </p>
<div class="fragment"><div class="line">* <a class="code" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#abced5952169a6146ab95d5aa9e4145ca">SDFDoc</a> mydoc(<span class="stringliteral">&quot;in.pdf&quot;</span>);</div>
<div class="line">* Obj trailer = mydoc.GetTrailer();</div>
<div class="line">* </div>
</div><!-- fragment --><p> or from a memory buffer or some other Filter/Stream such as a HTTP Filter connection:</p>
<div class="fragment"><div class="line">* MemoryFilter memory = ....</div>
<div class="line">* <a class="code" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#abced5952169a6146ab95d5aa9e4145ca">SDFDoc</a> mydoc(memory);</div>
<div class="line">* Obj trailer = mydoc.GetTrailer();</div>
<div class="line">* </div>
</div><!-- fragment --><p>Finally <a class="el" href="namespacepdftron_1_1_s_d_f.html">SDF</a> document can be accessed from a high-level <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> document as follows:</p>
<div class="fragment"><div class="line">* PDFDoc doc(<span class="stringliteral">&quot;in.pdf&quot;</span>);</div>
<div class="line">* <a class="code" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#abced5952169a6146ab95d5aa9e4145ca">SDFDoc</a>&amp; mydoc = doc.GetSDFDoc();</div>
<div class="line">* Obj trailer = mydoc.GetTrailer();</div>
<div class="line">* </div>
</div><!-- fragment --><p>Note that the examples above used doc.GetTrailer() in order to access document trailer, the starting <a class="el" href="namespacepdftron_1_1_s_d_f.html">SDF</a> object (root node) in every document. Following the trailer links, it is possible to visit all low-level objects in a document (e.g. all pages, outlines, fonts, etc).</p>
<p><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDFDoc</a> also provides utility methods used to import objects and object collections from one document to another. These methods can be useful for copy operations between documents such as a high-level page merge and document assembly. </p>

<p>Definition at line <a class="el" href="_s_d_f_doc_8h_source.html#l00067">67</a> of file <a class="el" href="_s_d_f_doc_8h_source.html">SDFDoc.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a5b3783848b2580a6711beef4b2e2d5cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a5b3783848b2580a6711beef4b2e2d5cc">pdftron::SDF::SDFDoc::SaveOptions</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a5b3783848b2580a6711beef4b2e2d5cca3adf8994ba8b0ba9a831142ffa34412f"></a>e_incremental</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5b3783848b2580a6711beef4b2e2d5ccadf55689d755e830879b1c57a4d9d1001"></a>e_remove_unused</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5b3783848b2580a6711beef4b2e2d5cca52b5a09e45ebf126476d2827c647e8bd"></a>e_hex_strings</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5b3783848b2580a6711beef4b2e2d5cca4903a0d9770323a5932a67e92c661265"></a>e_omit_xref</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5b3783848b2580a6711beef4b2e2d5cca594319c7a980e2bbcf209276a2c7b629"></a>e_linearized</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5b3783848b2580a6711beef4b2e2d5cca90b577a908d149c2c6b0a7e82702ecf0"></a>e_compatibility</em>&nbsp;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_s_d_f_doc_8h_source.html#l00352">352</a> of file <a class="el" href="_s_d_f_doc_8h_source.html">SDFDoc.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abced5952169a6146ab95d5aa9e4145ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pdftron::SDF::SDFDoc::SDFDoc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Creates a new document. The new document contains only trailer and Info dictionary. To build the rest of the document get document's root dictionary using <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a1b8825fba1daa3683495bae7491384e9">GetTrailer()</a> and populate it with new key/value pairs. </p>

</div>
</div>
<a class="anchor" id="aa2169401d12cfd4abd58c009c5017e17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pdftron::SDF::SDFDoc::SDFDoc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a SDF/Cos document from a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>- path name to the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Make sure to call <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a3322f357d399a7ee4d19ba630fe0a5f4">InitStdSecurityHandler()</a> or <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a50da682d96065666c6d0de5ffe9aef99">InitSecurityHandler()</a> after <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDFDoc</a>(...) in case the document is encrypted. </dd></dl>

</div>
</div>
<a class="anchor" id="a1415207c1b124a68738b6df71a94eb90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pdftron::SDF::SDFDoc::SDFDoc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a921cb7e648b32295172f83dcf0d14de3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pdftron::SDF::SDFDoc::SDFDoc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a>&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a SDF/Cos document from a Filter (i.e. a data stream) object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>- input stream containing a serialized document. The input stream may be a random-access file, memory buffer, slow HTTP connection etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>if the input stream doesn't support Seek() operation the document will load whole data stream in memory before parsing. In case of linearized <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a>, the document may be parsed on-the-fly while it is being loaded in memory. Note that since StdFile implements Seek() interface, the document does not have to be fully in memory before it is used.</dd>
<dd>
Make sure to call <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a3322f357d399a7ee4d19ba630fe0a5f4">InitStdSecurityHandler()</a> or <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a50da682d96065666c6d0de5ffe9aef99">InitSecurityHandler()</a> after <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDFDoc</a>(...) in case the document is encrypted. </dd></dl>

</div>
</div>
<a class="anchor" id="a058219b827a8d3f1dd3330268f240f1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pdftron::SDF::SDFDoc::SDFDoc </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a SDF/Cos document from a memory buffer.</p>
<dl class="section note"><dt>Note</dt><dd>the document should be fully loaded in the memory buffer. </dd>
<dd>
the buffer ownership is not transfered to the document so the user should clean-up if necessary.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- a memory buffer containing the serialized document </td></tr>
    <tr><td class="paramname">buf_size</td><td>- the size of memory buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Make sure to call <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a3322f357d399a7ee4d19ba630fe0a5f4">InitStdSecurityHandler()</a> or <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a50da682d96065666c6d0de5ffe9aef99">InitSecurityHandler()</a> after <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDFDoc</a>(...) in case the document is encrypted. </dd></dl>

</div>
</div>
<a class="anchor" id="a4316bf4a405ec4876c000fd3d1ce09af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pdftron::SDF::SDFDoc::~SDFDoc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad603a40259f0f7c965794719daa3d353"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::SDF::SDFDoc::ClearMarks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes 'marked' flag from all objects in cross reference table. </p>

</div>
</div>
<a class="anchor" id="a81712a6723ba9dcae984dbe4aadb1955"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::SDF::SDFDoc::Close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDFDoc</a> </p>

</div>
</div>
<a class="anchor" id="a29f453028bf1389d8727139626a43d85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> pdftron::SDF::SDFDoc::CreateIndirectArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to create SDF/Cos indirect object.</p>
<p>Unlike direct objects, indirect objects can be referenced by more than one object (i.e. indirect objects they can be shared).</p>
<dl class="section note"><dt>Note</dt><dd>In C++ doc.CreateIndirect???(...) is equivalent to ???::CreateIndirect(...). </dd></dl>

</div>
</div>
<a class="anchor" id="a79fd478cd346ba86a7b39a41995c801f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> pdftron::SDF::SDFDoc::CreateIndirectBool </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to create SDF/Cos indirect object.</p>
<p>Unlike direct objects, indirect objects can be referenced by more than one object (i.e. indirect objects they can be shared).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- indirect boolean to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In C++ doc.CreateIndirect???(...) is equivalent to ???::CreateIndirect(...). </dd></dl>

</div>
</div>
<a class="anchor" id="a32e93bc9e2ba27341e8ad641524dd4f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> pdftron::SDF::SDFDoc::CreateIndirectDict </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a987871e22fa1bb1c529008a413b7d6ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> pdftron::SDF::SDFDoc::CreateIndirectName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to create SDF/Cos indirect object.</p>
<p>Unlike direct objects, indirect objects can be referenced by more than one object (i.e. indirect objects they can be shared).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>- indirect const char* object to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In C++ doc.CreateIndirect???(...) is equivalent to ???::CreateIndirect(...). </dd></dl>

</div>
</div>
<a class="anchor" id="a525f114e74d79df33fe5ec9ee6328095"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> pdftron::SDF::SDFDoc::CreateIndirectNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae4a2ae1b8e27dc1795b0653de3bdf1b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> pdftron::SDF::SDFDoc::CreateIndirectNumber </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad2c1007b29e9f9c66b74c83abf274d50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> pdftron::SDF::SDFDoc::CreateIndirectStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_filters_1_1_filter_reader.html">Filters::FilterReader</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a>&#160;</td>
          <td class="paramname"><em>filter_chain</em> = <code><a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>After calling the following methods the filter object is invalidated and should not be used </dd></dl>

</div>
</div>
<a class="anchor" id="aaea6820cd9698c7c0e9766a7ca4f815c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> pdftron::SDF::SDFDoc::CreateIndirectStream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a>&#160;</td>
          <td class="paramname"><em>filter_chain</em> = <code><a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9843fede02ea3af760c62cacda9e26e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> pdftron::SDF::SDFDoc::CreateIndirectString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepdftron.html#a7bc90caf17b633a6832ec1e5162e1bc0">UChar</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab4e4b91cf02326157b6aa995dbbdeda7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> pdftron::SDF::SDFDoc::CreateIndirectString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adab10e902c3a4f83fe1c468beb7409dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDFDoc</a>* pdftron::SDF::SDFDoc::CreateInternal </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0a22fa5547a1ae2e8208ab023bc7809f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::SDF::SDFDoc::EnableDiskCaching </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_cache_flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A document uses a temporary file which is used to cache the contents of any new stream object created in the document (that is the default behavior). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">use_cache_flag</td><td>- true to enable caching, false to disable caching. Use this function to enable or disable this feature dynamically. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e6596cd267a7978cff33af3b50df0d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_u_string.html">UString</a> pdftron::SDF::SDFDoc::GetFileName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The filename of the document if the document is loaded from disk, or empty string if the document is not yet saved or is loaded from a memory buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a6572ab30f59e1670bbff1f5aa24b3ae8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t pdftron::SDF::SDFDoc::GetHandleInternal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3dc503d84cda3e38d758441e5a1baa36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* pdftron::SDF::SDFDoc::GetHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the header string identifying the document version to which the file conforms. For a file conforming to <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> version 1.4, the header should be PDF-1.4. In general header strings have the following syntax: AAA-N.n where AAA identifies document specification (such as <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a>, <a class="el" href="namespacepdftron_1_1_f_d_f.html">FDF</a>, PJTF etc), N is the major version and n is the minor version. The new header string can be set during a full save (see <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a29938306ef2e231dbc978ac525a215fe">SDFDoc::Save()</a>). For a document that is not serialized the function returns an empty string. </dd></dl>

</div>
</div>
<a class="anchor" id="a35c66e3dbe041e987f0b50c07a4ec4cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> pdftron::SDF::SDFDoc::GetHintStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns document's initial linearization hint stream if it is available.</p>
<dl class="section return"><dt>Returns</dt><dd>- the linearization hint stream of the original document or NULL if the hint stream is not available. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4bcdcd13f8ad39ac93d3f435fccbade"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> pdftron::SDF::SDFDoc::GetLinearizationDict </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns document's initial linearization dictionary if it is available.</p>
<dl class="section return"><dt>Returns</dt><dd>- the linearization dictionary of the original document or NULL if the dictionary is not available. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7d4f39e28e6700b6b4f67500c2fca2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> pdftron::SDF::SDFDoc::GetObj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a>&#160;</td>
          <td class="paramname"><em>obj_num</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_num</td><td>- object number of the object to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- the latest version of the object matching specified object number. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">-</td><td>exception is thrown if the object is not found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad17034c03a891fae0c9124c31e8b0cfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_security_handler.html">SecurityHandler</a> pdftron::SDF::SDFDoc::GetSecurityHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Currently selected <a class="el" href="classpdftron_1_1_s_d_f_1_1_security_handler.html">SecurityHandler</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a50da682d96065666c6d0de5ffe9aef99">InitSecurityHandler()</a> should be called before <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#ad17034c03a891fae0c9124c31e8b0cfa">GetSecurityHandler()</a> in order to initialize the handler.</dd>
<dd>
Returned security handler can be modified in order to change the security settings of the existing document. Changes to the current handler will not invalidate the access to the original file and will take effect during document <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a29938306ef2e231dbc978ac525a215fe">Save()</a>.</dd>
<dd>
If the security handler is modified, document will perform a full save even if e_incremental was given as a flag in <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a29938306ef2e231dbc978ac525a215fe">Save()</a> method. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b8825fba1daa3683495bae7491384e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> pdftron::SDF::SDFDoc::GetTrailer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>- A dictionary representing the root of the document (i.e. a document trailer dictionary) </dd></dl>

</div>
</div>
<a class="anchor" id="a325c16e6051b56e37298779efb8ae001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::SDF::SDFDoc::HasRepairedXRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether or not the underlying file has an XRef table that had to be repaired when the file was opened. If the document had an invalid XRef table when opened, <a class="el" href="classpdftron_1_1_p_d_f_net.html">PDFNet</a> will have repaired the XRef table for its working representation of the document.</p>
<dl class="section return"><dt>Returns</dt><dd>- true if document was found to be corrupted, and was repaired, during opening and has not been saved since.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>- If this function returns true, it is not possible to incrementally save the document (see <a href="http://www.pdftron.com/kb_corrupt_xref">http://www.pdftron.com/kb_corrupt_xref</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="a4de0a926d1127e509317f067e98e9a69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> pdftron::SDF::SDFDoc::ImportObj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a>&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deep_copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>- an object to import. </td></tr>
    <tr><td class="paramname">deep_copy</td><td>- a boolean indicating whether to perform a deep or shallow copy. In case of shallow copy all indirect references will be set to null.</td></tr>
  </table>
  </dd>
</dl>
<p>If the object belongs to a document the function will perform deep or shallow clone depending whether deep_copy flag was specified.</p>
<p>If the object does not belong to any document ImportObj does not take the object ownership. ImportObj copies the source object and it is users responsibility to delete free objects.</p>
<dl class="section return"><dt>Returns</dt><dd>- a pointer to the root indirect object in this document </dd></dl>

</div>
</div>
<a class="anchor" id="a4de5fbb7fc6910e8b0bc07ebcdda1af4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a>&gt; pdftron::SDF::SDFDoc::ImportObjs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function performs a deep copy of all objects specified in the 'obj_list'. If objects in the list are directly or indirectly referring to the same object/s, only one copy of the shared object/s will be copied. Therefore, unlike repeated calls to ImportObj, this method will import only one copy of shared objects (objects representing an intersection of graphs specified through 'obj_list' of root pointers.</p>
<dl class="section note"><dt>Note</dt><dd>- All object in the import list must belong to the same source document. </dd>
<dd>
- The function does not perform the shallow copy since <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a4de0a926d1127e509317f067e98e9a69">ImportObj()</a> can be used instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_list</td><td>- a list of root objects to import. All directly or indirectly objects will be imported as well. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- a list of imported root objects in this document. </dd></dl>

</div>
</div>
<a class="anchor" id="ad655d5226067b50270373e0236f67617"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a>&gt; pdftron::SDF::SDFDoc::ImportObjs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">Obj</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exclude_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function performs a deep copy of all objects specified in the 'obj_list'. If objects in the list are directly or indirectly referring to the same object/s, only one copy of the shared object/s will be copied. Therefore, unlike repeated calls to ImportObj, this method will import only one copy of shared objects (objects representing an intersection of graphs specified through 'obj_list' of root pointers.</p>
<dl class="section note"><dt>Note</dt><dd>- All object in the import list must belong to the same source document. </dd>
<dd>
- The function does not perform the shallow copy since <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a4de0a926d1127e509317f067e98e9a69">ImportObj()</a> can be used instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_list</td><td>- a list of root objects to import. All directly or indirectly objects will be imported as well. </td></tr>
    <tr><td class="paramname">exclude_list</td><td>- a list of objects to not include in the deep copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- a list of imported root objects in this document. </dd></dl>

</div>
</div>
<a class="anchor" id="a50da682d96065666c6d0de5ffe9aef99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::SDF::SDFDoc::InitSecurityHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>custom_data</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes document's <a class="el" href="classpdftron_1_1_s_d_f_1_1_security_handler.html">SecurityHandler</a>. This version of <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a50da682d96065666c6d0de5ffe9aef99">InitSecurityHandler()</a> works with Standard and Custom <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> security and can be used in situations where the password is obtained dynamically via user feedback. See EncTest sample for example code.</p>
<p>This function should be called immediately after an encrypted document is opened. The function does not have any side effects on documents that are not encrypted.</p>
<p>If the security handler was successfully initialized it can be later obtained using <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#ad17034c03a891fae0c9124c31e8b0cfa">GetSecurityHandler()</a> method.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">An</td><td>exception is thrown if the matching handler for document's security was not found in the global SecurityManager. In this case, you need to register additional custom security handlers with the global SecurityManager (using SecurityManagerSingleton).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classpdftron_1_1_s_d_f_1_1_security_handler.html">SecurityHandler</a> was successfully initialized (this may include authentication data collection, verification etc.), false otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">custom_data</td><td>An optional parameter used to specify custom data that should be passed in SecurityHandler::Initialize() callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3322f357d399a7ee4d19ba630fe0a5f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::SDF::SDFDoc::InitStdSecurityHandler </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>password_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes document's <a class="el" href="classpdftron_1_1_s_d_f_1_1_security_handler.html">SecurityHandler</a> using the supplied password. This version of <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a50da682d96065666c6d0de5ffe9aef99">InitSecurityHandler()</a> assumes that document uses Standard security and that a password is specified directly.</p>
<p>This function should be called immediately after an encrypted document is opened. The function does not have any side effects on documents that are not encrypted.</p>
<p>If the security handler was successfully initialized, it can be later obtained using <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#ad17034c03a891fae0c9124c31e8b0cfa">GetSecurityHandler()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the given password successfully unlocked the document, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">An</td><td>exception is thrown if the document's security Filter is not 'Standard'. In this case, you need to register additional custom security handlers with the global SecurityManager (SecurityManagerSingleton).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>Specifies the password used to open the document without any user feedback. If you would like to dynamically obtain the password, you need to derive a custom class from StdSecurityHandler() and use <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a50da682d96065666c6d0de5ffe9aef99">InitSecurityHandler()</a> without any parameters. See EncTest sample for example code.</td></tr>
    <tr><td class="paramname">password_sz</td><td>An optional parameter used to specify the size of the password buffer, in bytes. If the 'password_sz' is 0, or if the parameter is not specified, the function assumes that the string is null terminated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Deprecated. Use versions that accepts <a class="el" href="classpdftron_1_1_u_string.html">UString</a> or buffer instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a70e40581c13dfd2368d6a27d19a7d2d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::SDF::SDFDoc::InitStdSecurityHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">pdftron::UString</a> &amp;&#160;</td>
          <td class="paramname"><em>password</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes document's <a class="el" href="classpdftron_1_1_s_d_f_1_1_security_handler.html">SecurityHandler</a> using the supplied password. This version of <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a50da682d96065666c6d0de5ffe9aef99">InitSecurityHandler()</a> assumes that document uses Standard security and that a password is specified directly.</p>
<p>This function should be called immediately after an encrypted document is opened. The function does not have any side effects on documents that are not encrypted.</p>
<p>If the security handler was successfully initialized, it can be later obtained using <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#ad17034c03a891fae0c9124c31e8b0cfa">GetSecurityHandler()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>Specifies the password used to open the document without any user feedback. If you would like to dynamically obtain the password, you need to derive a custom class from StdSecurityHandler() and use <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a50da682d96065666c6d0de5ffe9aef99">InitSecurityHandler()</a> without any parameters. See EncTest sample for example code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the given password successfully unlocked the document, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">An</td><td>exception is thrown if the document's security Filter is not 'Standard'. In this case, you need to register additional custom security handlers with the global SecurityManager (SecurityManagerSingleton). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60f6c0769e5b109feb9d67ad8ec38521"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::SDF::SDFDoc::InitStdSecurityHandler </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacepdftron.html#a2538e0861ab3366a3bfab3665d0cd137">UInt8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>password_buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes document's <a class="el" href="classpdftron_1_1_s_d_f_1_1_security_handler.html">SecurityHandler</a> using the supplied password. This version of <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a50da682d96065666c6d0de5ffe9aef99">InitSecurityHandler()</a> assumes that document uses Standard security and that a password is specified directly.</p>
<p>This function should be called immediately after an encrypted document is opened. The function does not have any side effects on documents that are not encrypted.</p>
<p>If the security handler was successfully initialized, it can be later obtained using <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#ad17034c03a891fae0c9124c31e8b0cfa">GetSecurityHandler()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password_buf</td><td>Specifies the password used to open the document without any user feedback. If you would like to dynamically obtain the password, you need to derive a custom class from StdSecurityHandler() and use <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a50da682d96065666c6d0de5ffe9aef99">InitSecurityHandler()</a> without any parameters. See EncTest sample for example code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the given password successfully unlocked the document, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">An</td><td>exception is thrown if the document's security Filter is not 'Standard'. In this case, you need to register additional custom security handlers with the global SecurityManager (SecurityManagerSingleton). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c0d530e9b69297ef2814ad015e5da61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::SDF::SDFDoc::IsEncrypted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the document is/was originally encrypted false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a16df7a03d92aa721e5e3f42436b07f70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::SDF::SDFDoc::IsFullSaveRequired </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>- true if the document requires full save. </dd></dl>

</div>
</div>
<a class="anchor" id="abfbfcfe763d0f164c71f49cc6df0b3e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::SDF::SDFDoc::IsLinearized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call this function to determine whether the document is represented in linearized (fast web view) format.</p>
<dl class="section return"><dt>Returns</dt><dd>- true if document is stored in fast web view format, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>any changes to the document can invalidate linearization. The function will return 'true' only if the original document is linearized and if it is not modified.</dd></dl>
<p>In order to provide good performance over relatively slow communication links, <a class="el" href="classpdftron_1_1_p_d_f_net.html">PDFNet</a> can generate <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> documents with linearized objects and hint tables that can allow a <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> viewer application to download and view one page of a <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> file at a time, rather than requiring the entire file (including fonts and images) to be downloaded before any of it can be viewed.</p>
<p>To save a document in linearized (fast web view) format you only need to pass 'SDFDoc.SaveOptions.e_linearized' flag in the Save method. </p>

</div>
</div>
<a class="anchor" id="ab2ff2e516c0db3b24b7555dfdb1d0637"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::SDF::SDFDoc::IsModified </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>- true if document was modified, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a34d916a8e9c29f757f6f3d6d7dcb0bad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::SDF::SDFDoc::Lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locks the document to prevent competing threads from accessing the document at the same time. Threads attempting to access the document will wait in suspended state until the thread that owns the lock calls doc.Unlock(). </p>

</div>
</div>
<a class="anchor" id="adb3735bb11b7d2ec7ed52a22d5ac29e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::SDF::SDFDoc::LockRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locks the document to prevent competing write threads (using <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a34d916a8e9c29f757f6f3d6d7dcb0bad">Lock()</a>) from accessing the document at the same time. Other reader threads however, will be allowed to access the document. Threads attempting to obtain write access to the document will wait in suspended state until the thread that owns the lock calls doc.UnlockRead(). Note: To avoid deadlocks obtaining a write lock while holding a read lock is not permitted and will throw an exception. If this situation is encountered please either unlock the read lock before the write lock is obtained or acquire a write lock (rather than read lock) in the first place. </p>

</div>
</div>
<a class="anchor" id="ad87c650027636e24f9aa9d73f5dccfbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::SDF::SDFDoc::RemoveSecurity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function removes document security. </p>

</div>
</div>
<a class="anchor" id="a29938306ef2e231dbc978ac525a215fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::SDF::SDFDoc::Save </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Common::ProgressMonitor *&#160;</td>
          <td class="paramname"><em>progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the document to a file.</p>
<p>If a full save is requested to the original path, the file is saved to a file system-determined temporary file, the old file is deleted, and the temporary file is renamed to path.</p>
<p>A full save with remove unused or linearization option may re-arrange object in the cross reference table. Therefore all pointers and references to document objects and resources should be re acquired in order to continue document editing.</p>
<p>In order to use incremental save the specified path must match original path and e_incremental flag bit should be set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>- The full path name to which the file is saved. </td></tr>
    <tr><td class="paramname">flags</td><td>- A bit field composed of an OR of the <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a5b3783848b2580a6711beef4b2e2d5cc">SDFDoc::SaveOptions</a> values. </td></tr>
    <tr><td class="paramname">progress</td><td>- A pointer to the progress interface. NULL if progress tracking is not required. </td></tr>
    <tr><td class="paramname">header</td><td>- File header. A new file header is set only during full save.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">-</td><td>if the file can't be opened for saving or if there is a problem during Save an Exception object will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>- Save will modify the <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDFDoc</a> object's internal representation. As such, the user should acquire a write lock before calling save. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7dbf76f70b53357569ed3c6c86a9c39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::SDF::SDFDoc::Save </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the document to a file.</p>
<p>If a full save is requested to the original path, the file is saved to a file system-determined temporary file, the old file is deleted, and the temporary file is renamed to path.</p>
<p>A full save with remove unused or linearization option may re-arrange object in the cross reference table. Therefore all pointers and references to document objects and resources should be re acquired in order to continue document editing.</p>
<p>In order to use incremental save the specified path must match original path and e_incremental flag bit should be set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>- The full path name to which the file is saved. </td></tr>
    <tr><td class="paramname">flags</td><td>- A bit field composed of an OR of the <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a5b3783848b2580a6711beef4b2e2d5cc">SDFDoc::SaveOptions</a> values. </td></tr>
    <tr><td class="paramname">header</td><td>- File header. A new file header is set only during full save.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">-</td><td>if the file can't be opened for saving or if there is a problem during Save an Exception object will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>- Save will modify the <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDFDoc</a> object's internal representation. As such, the user should acquire a write lock before calling save. </dd></dl>

</div>
</div>
<a class="anchor" id="a144c773265eabc529fb1b5a2960063e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned char&gt; pdftron::SDF::SDFDoc::Save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the document to a memory buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>- A bit field composed of an OR of the <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a5b3783848b2580a6711beef4b2e2d5cc">SDFDoc::SaveOptions</a> values. Note that this method ignores e_incremental flag. </td></tr>
    <tr><td class="paramname">header</td><td>- File header. A new file header is set only during full save.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the buffer containing the serialized version of the document.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">-</td><td>if there is a problem during Save an Exception object will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>- Save will modify the <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDFDoc</a> object's internal representation. As such, the user should acquire a write lock before calling save. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a1e3919ca0b8af6aafae3f8ce548571"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::SDF::SDFDoc::Save </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>out_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>out_buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Common::ProgressMonitor *&#160;</td>
          <td class="paramname"><em>progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the document to a memory buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_buf</td><td>a pointer to the buffer containing the serialized version of the document. (C++ Note) The buffer is owned by a document and the client doesn't need to do any initialization or cleanup. </td></tr>
    <tr><td class="paramname">out_buf_size</td><td>the size of the serialized document (i.e. out_buf) in bytes.</td></tr>
    <tr><td class="paramname">flags</td><td>- A bit field composed of an OR of the <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a5b3783848b2580a6711beef4b2e2d5cc">SDFDoc::SaveOptions</a> values. Note that this method ignores e_incremental flag. </td></tr>
    <tr><td class="paramname">progress</td><td>- A pointer to the progress interface. NULL if progress tracking is not required. </td></tr>
    <tr><td class="paramname">header</td><td>- File header. A new file header is set only during full save.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">-</td><td>if there is a problem during Save an Exception object will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>- Save will modify the <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDFDoc</a> object's internal representation. As such, the user should acquire a write lock before calling save. </dd></dl>

</div>
</div>
<a class="anchor" id="add1951756a421770eea970606919e44a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::SDF::SDFDoc::Save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a>&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the document to a stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The output stream where to write data. </td></tr>
    <tr><td class="paramname">flags</td><td>- A bit field composed of an OR of the <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a5b3783848b2580a6711beef4b2e2d5cc">SDFDoc::SaveOptions</a> values. </td></tr>
    <tr><td class="paramname">progress</td><td>- A pointer to the progress interface. NULL if progress tracking is not required. </td></tr>
    <tr><td class="paramname">header</td><td>- File header. A new file header is set only during full save. See also <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a3dc503d84cda3e38d758441e5a1baa36">GetHeader()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">-</td><td>if there is a problem during Save an Exception object will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>- Save will modify the <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDFDoc</a> object's internal representation. As such, the user should acquire a write lock before calling save. </dd></dl>

</div>
</div>
<a class="anchor" id="a415ee38c8e7e7f2042700acfad753e23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::SDF::SDFDoc::SetSecurityHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_s_d_f_1_1_security_handler.html">SecurityHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function sets a new <a class="el" href="classpdftron_1_1_s_d_f_1_1_security_handler.html">SecurityHandler</a> as the current security handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>- new <a class="el" href="classpdftron_1_1_s_d_f_1_1_security_handler.html">SecurityHandler</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Setting a new security handler will not invalidate the access to the original file and will take effect during document <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a29938306ef2e231dbc978ac525a215fe">Save()</a>.</dd>
<dd>
If the security handler is modified, document will perform a full save even if e_incremental was given as a flag in <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html#a29938306ef2e231dbc978ac525a215fe">Save()</a> method. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8cdc09ebee857d2d83e499cffd79af4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::SDF::SDFDoc::Swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a>&#160;</td>
          <td class="paramname"><em>obj_num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a>&#160;</td>
          <td class="paramname"><em>obj_num2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sometimes it is desirable to modify all indirect references to a given indirect object. It would be inefficient to manually search for all indirect references to a given indirect object.</p>
<p>A more efficient and less error prone method is to replace the indirect object in the cross reference table with a new object. This way the object that is referred to is modified (or replaced) and indirect references do not have to be changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_num1</td><td>- object number of first object to be swapped. </td></tr>
    <tr><td class="paramname">obj_num2</td><td>- object number of second object to be swapped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">the</td><td>function throws exception in case the swap can't be performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac05a56219ad2c9e8b9d9970873484bf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::SDF::SDFDoc::TryLock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>milliseconds</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try locking the document, waiting no longer than specified number of milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>- max number of milliseconds to wait for the document to lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the document is locked for multi-threaded access, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a577ac29335caa15cba553c6ec565aed9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::SDF::SDFDoc::TryLockRead </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>milliseconds</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try locking the document, waiting no longer than specified number of milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>- max number of milliseconds to wait for the document to lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the document is locked for multi-threaded access, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a273e72802115c890d80928a4337ad253"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::SDF::SDFDoc::Unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the lock from the document. </p>

</div>
</div>
<a class="anchor" id="ad16489888bfaa12ae2e08678f2d32dbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::SDF::SDFDoc::UnlockRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the lock from the document. </p>

</div>
</div>
<a class="anchor" id="ae79b6ec7237971730d314d1906f8269e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a> pdftron::SDF::SDFDoc::XRefSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>- The size of cross reference table </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>SDF/<a class="el" href="_s_d_f_doc_8h_source.html">SDFDoc.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="footer">
<hr>
<small>
&copy 2001-2021 <a href="http://www.pdftron.com/">PDFTron Systems Inc.</a>
</small>
</div>
</body>
</html>
