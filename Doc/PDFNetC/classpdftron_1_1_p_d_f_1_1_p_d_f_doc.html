<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>PDFTron PDFNet API Reference C++ API</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="pdftron_resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); fixDoxygen();});
</script>
<link href="https://fonts.googleapis.com/css?family=Lato:400,700&display=swap&subset=latin-ext" rel="stylesheet">
<link href="pdftron_doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table style="width:100%;" cellspacing="0" cellpadding="0">
    <tbody>
        <tr class="logorow">
            <td id="projectlogo">
                <a href="http://www.pdftron.com/">
                    <img alt="Logo" src="banner_logo.svg"/>
                </a>
            </td>
        </tr>
    </tbody>
</table>
</div><!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pdftron::PDF::PDFDoc Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_p_d_f_doc_8h_source.html">PDFDoc.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a17d1f00bcaf9272f316b2bd0adc28cb5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a17d1f00bcaf9272f316b2bd0adc28cb5">ActionTriggerEvent</a> { <br/>
&#160;&#160;<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a17d1f00bcaf9272f316b2bd0adc28cb5a5b61782e5cb569c3192183a074707ea6">e_action_trigger_doc_will_close</a> = 17, 
<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a17d1f00bcaf9272f316b2bd0adc28cb5a0a98a3b87fa034e653b8d6087fd1f94d">e_action_trigger_doc_will_save</a> = 18, 
<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a17d1f00bcaf9272f316b2bd0adc28cb5a615d2500089a4cbd2a4d0b940893f9de">e_action_trigger_doc_did_save</a> = 19, 
<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a17d1f00bcaf9272f316b2bd0adc28cb5af4ea663a8f0509d9d3d96b7ed39de17f">e_action_trigger_doc_will_print</a> = 20, 
<br/>
&#160;&#160;<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a17d1f00bcaf9272f316b2bd0adc28cb5a2d81136d09f77d9c095b24e8a62da7e7">e_action_trigger_doc_did_print</a> = 21
<br/>
 }</td></tr>
<tr class="separator:a17d1f00bcaf9272f316b2bd0adc28cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43e9216b77ce9c7f52290f17bdbfc4d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ac43e9216b77ce9c7f52290f17bdbfc4d">InsertFlag</a> { <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ac43e9216b77ce9c7f52290f17bdbfc4dad780b7aba1fa38ff9aaeb5a4f50accb2">e_none</a>, 
<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ac43e9216b77ce9c7f52290f17bdbfc4da8e56f3c4c6460c92b393b3ef17d35540">e_insert_bookmark</a>, 
<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ac43e9216b77ce9c7f52290f17bdbfc4da44ba9cf9fdac1c70db9b15fbcafd7a02">e_insert_goto_bookmark</a>
 }</td></tr>
<tr class="separator:ac43e9216b77ce9c7f52290f17bdbfc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7967f365a4c14369836db9c3a43d4163"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7967f365a4c14369836db9c3a43d4163">ExtractFlag</a> { <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7967f365a4c14369836db9c3a43d4163ac76092a7e88aace0b2e947b27df9bc4a">e_forms_only</a>, 
<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7967f365a4c14369836db9c3a43d4163a98b7b5a30657ed23ec4b624794a3aada">e_annots_only</a>, 
<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7967f365a4c14369836db9c3a43d4163a989e4866df6de947a70696a4d66b233a">e_both</a>, 
<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7967f365a4c14369836db9c3a43d4163a2aeb8b12269c00bef7db09906a655cb6">e_annots_only_no_links</a> = 5
 }</td></tr>
<tr class="separator:a7967f365a4c14369836db9c3a43d4163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb06ed1ead06ee4cb4f383b3d655ee59"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#acb06ed1ead06ee4cb4f383b3d655ee59">SignaturesVerificationStatus</a> { <br/>
&#160;&#160;<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#acb06ed1ead06ee4cb4f383b3d655ee59ac795b15d37d4e1a0944a34b15669a10b">e_unsigned</a>, 
<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#acb06ed1ead06ee4cb4f383b3d655ee59ae3569e6beef10560ad16f2da9ead3102">e_failure</a>, 
<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#acb06ed1ead06ee4cb4f383b3d655ee59a80637e5489e042b80010e8522be6f3fd">e_untrusted</a>, 
<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#acb06ed1ead06ee4cb4f383b3d655ee59aa92409b7bcdbf04360001e328ce9f9a9">e_unsupported</a>, 
<br/>
&#160;&#160;<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#acb06ed1ead06ee4cb4f383b3d655ee59a588b4e452d46118346d74739a3b2c233">e_verified</a>
<br/>
 }</td></tr>
<tr class="separator:acb06ed1ead06ee4cb4f383b3d655ee59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4ae987ae6a379949e5beeb3f30182852"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a4ae987ae6a379949e5beeb3f30182852">PDFDoc</a> ()</td></tr>
<tr class="separator:a4ae987ae6a379949e5beeb3f30182852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a46ca7bfdf7998d304d5b2251c014a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#af0a46ca7bfdf7998d304d5b2251c014a">PDFDoc</a> (<a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDF::SDFDoc</a> &amp;sdfdoc)</td></tr>
<tr class="separator:af0a46ca7bfdf7998d304d5b2251c014a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61703e97010ccb0b4f642cc062aed66d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a61703e97010ccb0b4f642cc062aed66d">PDFDoc</a> (const <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;other)</td></tr>
<tr class="separator:a61703e97010ccb0b4f642cc062aed66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83504d30edb68eaacd6417458af2f5a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a83504d30edb68eaacd6417458af2f5a2">operator=</a> (const <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;)</td></tr>
<tr class="separator:a83504d30edb68eaacd6417458af2f5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01413dce319bc93dd6eced5077d435a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a01413dce319bc93dd6eced5077d435a5">PDFDoc</a> (const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;filepath)</td></tr>
<tr class="separator:a01413dce319bc93dd6eced5077d435a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ef303f66bf212280dc82be2573fa17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a82ef303f66bf212280dc82be2573fa17">PDFDoc</a> (const char *filepath)</td></tr>
<tr class="separator:a82ef303f66bf212280dc82be2573fa17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acece1703ff2d7b6cd85fb0e52c0e72c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#acece1703ff2d7b6cd85fb0e52c0e72c8">PDFDoc</a> (<a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a> stream)</td></tr>
<tr class="separator:acece1703ff2d7b6cd85fb0e52c0e72c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1e6bd9ad0037bcacc59744855a2c0a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a5f1e6bd9ad0037bcacc59744855a2c0a">PDFDoc</a> (const <a class="el" href="namespacepdftron.html#a7bc90caf17b633a6832ec1e5162e1bc0">UChar</a> *buf, size_t buf_size)</td></tr>
<tr class="separator:a5f1e6bd9ad0037bcacc59744855a2c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7719c185b93542c5bee4592c871ce83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#aa7719c185b93542c5bee4592c871ce83">~PDFDoc</a> ()</td></tr>
<tr class="separator:aa7719c185b93542c5bee4592c871ce83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511fad638795208aaf0f4401b7c2b926"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a511fad638795208aaf0f4401b7c2b926">Close</a> ()</td></tr>
<tr class="separator:a511fad638795208aaf0f4401b7c2b926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9410730cef91472ecf9a472c772e83d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a9410730cef91472ecf9a472c772e83d0">IsEncrypted</a> ()</td></tr>
<tr class="separator:a9410730cef91472ecf9a472c772e83d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0d28e22efa7856249874012a81d4fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#adc0d28e22efa7856249874012a81d4fe">InitSecurityHandler</a> (void *custom_data=0)</td></tr>
<tr class="separator:adc0d28e22efa7856249874012a81d4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf066e5ddfd8311e2257702e2c05e0b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#acf066e5ddfd8311e2257702e2c05e0b2">InitStdSecurityHandler</a> (const char *password, int password_sz)</td></tr>
<tr class="separator:acf066e5ddfd8311e2257702e2c05e0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5fa9c6a75b23a8b070960a8f0d3e55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a8b5fa9c6a75b23a8b070960a8f0d3e55">InitStdSecurityHandler</a> (const <a class="el" href="classpdftron_1_1_u_string.html">pdftron::UString</a> &amp;password)</td></tr>
<tr class="separator:a8b5fa9c6a75b23a8b070960a8f0d3e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9892fd705ebbe4910513f23116b469ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a9892fd705ebbe4910513f23116b469ee">InitStdSecurityHandler</a> (const std::vector&lt; <a class="el" href="namespacepdftron.html#a2538e0861ab3366a3bfab3665d0cd137">UInt8</a> &gt; &amp;password_buf)</td></tr>
<tr class="separator:a9892fd705ebbe4910513f23116b469ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ae14bfbc42ce8efaca89cd5095e706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_security_handler.html">SDF::SecurityHandler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#af8ae14bfbc42ce8efaca89cd5095e706">GetSecurityHandler</a> ()</td></tr>
<tr class="separator:af8ae14bfbc42ce8efaca89cd5095e706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ceed09f67451efc4599a4d97627ecf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ac5ceed09f67451efc4599a4d97627ecf">SetSecurityHandler</a> (const <a class="el" href="classpdftron_1_1_s_d_f_1_1_security_handler.html">SDF::SecurityHandler</a> &amp;handler)</td></tr>
<tr class="separator:ac5ceed09f67451efc4599a4d97627ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5303073494e2f3d87e7d49388722e73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ae5303073494e2f3d87e7d49388722e73">RemoveSecurity</a> ()</td></tr>
<tr class="separator:ae5303073494e2f3d87e7d49388722e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a871d707a670880eff9cea9f943318"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a46a871d707a670880eff9cea9f943318">HasSignatures</a> ()</td></tr>
<tr class="separator:a46a871d707a670880eff9cea9f943318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca4b550724a5c605876f1ac0b148640"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepdftron_1_1_s_d_f.html#a38b73540250fd07f741bbe4fba66634a">SDF::SignatureHandlerId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a5ca4b550724a5c605876f1ac0b148640">AddSignatureHandler</a> (const <a class="el" href="classpdftron_1_1_s_d_f_1_1_signature_handler.html">SDF::SignatureHandler</a> &amp;signature_handler)</td></tr>
<tr class="separator:a5ca4b550724a5c605876f1ac0b148640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d017a37d0aea3c70c3adfe65db3e49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepdftron_1_1_s_d_f.html#a38b73540250fd07f741bbe4fba66634a">SDF::SignatureHandlerId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a75d017a37d0aea3c70c3adfe65db3e49">AddStdSignatureHandler</a> (const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;pkcs12_keyfile, const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;pkcs12_keypass)</td></tr>
<tr class="separator:a75d017a37d0aea3c70c3adfe65db3e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2120a611f4d61cbff50f3411e9f4781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepdftron_1_1_s_d_f.html#a38b73540250fd07f741bbe4fba66634a">SDF::SignatureHandlerId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ad2120a611f4d61cbff50f3411e9f4781">AddStdSignatureHandler</a> (const std::vector&lt; unsigned char &gt; &amp;pkcs12_keybuffer, const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;pkcs12_keypass)</td></tr>
<tr class="separator:ad2120a611f4d61cbff50f3411e9f4781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a87c60bcfad1e97112006017241d3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a85a87c60bcfad1e97112006017241d3e">RemoveSignatureHandler</a> (const <a class="el" href="namespacepdftron_1_1_s_d_f.html#a38b73540250fd07f741bbe4fba66634a">SDF::SignatureHandlerId</a> signature_handler_id)</td></tr>
<tr class="separator:a85a87c60bcfad1e97112006017241d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254315cd040e3d927faa00f8591a276d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_signature_handler.html">SDF::SignatureHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a254315cd040e3d927faa00f8591a276d">GetSignatureHandler</a> (const <a class="el" href="namespacepdftron_1_1_s_d_f.html#a38b73540250fd07f741bbe4fba66634a">SDF::SignatureHandlerId</a> signature_handler_id)</td></tr>
<tr class="separator:a254315cd040e3d927faa00f8591a276d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02f45cdc6a9114a42c89ea915c7529d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_undo_manager.html">SDF::UndoManager</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ac02f45cdc6a9114a42c89ea915c7529d">GetUndoManager</a> ()</td></tr>
<tr class="separator:ac02f45cdc6a9114a42c89ea915c7529d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26de22e1354fa0f4cc5ce5b49cb0efbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_p_d_f_1_1_digital_signature_field.html">PDF::DigitalSignatureField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a26de22e1354fa0f4cc5ce5b49cb0efbb">CreateDigitalSignatureField</a> (const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;in_sig_field_name=&quot;&quot;)</td></tr>
<tr class="separator:a26de22e1354fa0f4cc5ce5b49cb0efbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fb360e6e72899f5ef0f6fb99fcf360"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepdftron_1_1_p_d_f.html#a98427c21d1e70ce06e74ecce1427b9fa">PDF::DigitalSignatureFieldIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#aa4fb360e6e72899f5ef0f6fb99fcf360">GetDigitalSignatureFieldIterator</a> ()</td></tr>
<tr class="separator:aa4fb360e6e72899f5ef0f6fb99fcf360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd0ba5c922d2d1788eec1091840d232"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_p_d_f_1_1_digital_signature_field.html#a4f38ee2e140cc95d81cc9faeff99e10f">PDF::DigitalSignatureField::DocumentPermissions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7bd0ba5c922d2d1788eec1091840d232">GetDigitalSignaturePermissions</a> () const </td></tr>
<tr class="separator:a7bd0ba5c922d2d1788eec1091840d232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42895db2ec142cf9d372c3418c6d2765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc_info.html">PDFDocInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a42895db2ec142cf9d372c3418c6d2765">GetDocInfo</a> ()</td></tr>
<tr class="separator:a42895db2ec142cf9d372c3418c6d2765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627467adeb4d6bcc6488cdaae2b56e1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc_view_prefs.html">PDFDocViewPrefs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a627467adeb4d6bcc6488cdaae2b56e1b">GetViewPrefs</a> ()</td></tr>
<tr class="separator:a627467adeb4d6bcc6488cdaae2b56e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab2dc9379e183dc58cc6f6ab638b7c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a5ab2dc9379e183dc58cc6f6ab638b7c4">GetTriggerAction</a> (<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a17d1f00bcaf9272f316b2bd0adc28cb5">PDFDoc::ActionTriggerEvent</a> trigger)</td></tr>
<tr class="separator:a5ab2dc9379e183dc58cc6f6ab638b7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563c1ffb754d2fb10ed9bec3583e19d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a563c1ffb754d2fb10ed9bec3583e19d7">IsModified</a> () const </td></tr>
<tr class="separator:a563c1ffb754d2fb10ed9bec3583e19d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc52e937bd061e822691a165b26c7f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#aabc52e937bd061e822691a165b26c7f1">HasRepairedXRef</a> () const </td></tr>
<tr class="separator:aabc52e937bd061e822691a165b26c7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ab756dbd661949ea74b204616c232d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ae8ab756dbd661949ea74b204616c232d">IsLinearized</a> () const </td></tr>
<tr class="separator:ae8ab756dbd661949ea74b204616c232d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7332c36cfb00e02ca4ef89bb70dc3eab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7332c36cfb00e02ca4ef89bb70dc3eab">HasDownloader</a> ()</td></tr>
<tr class="separator:a7332c36cfb00e02ca4ef89bb70dc3eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7c876e5698d03a01f64ecd0104e3c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepdftron.html#a6106f9362df99a4041d3a446effd70fb">UInt64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a5f7c876e5698d03a01f64ecd0104e3c5">GetDownloadedByteCount</a> ()</td></tr>
<tr class="separator:a5f7c876e5698d03a01f64ecd0104e3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcafeea21843f9cc6d96522eba503090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepdftron.html#a6106f9362df99a4041d3a446effd70fb">UInt64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#afcafeea21843f9cc6d96522eba503090">GetTotalRemoteByteCount</a> ()</td></tr>
<tr class="separator:afcafeea21843f9cc6d96522eba503090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad486c18e60424b253164bfaa481a759b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ad486c18e60424b253164bfaa481a759b">Save</a> (const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;path, <a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a> flags)</td></tr>
<tr class="separator:ad486c18e60424b253164bfaa481a759b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f74bf3a5a4b8243f96083134eaa3100"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a8f74bf3a5a4b8243f96083134eaa3100">Save</a> (const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;path, <a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a> flags, Common::ProgressMonitor *progress)</td></tr>
<tr class="separator:a8f74bf3a5a4b8243f96083134eaa3100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65f10be4f459a6f11227487bc9baa91"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#af65f10be4f459a6f11227487bc9baa91">Save</a> (<a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a> flags)</td></tr>
<tr class="separator:af65f10be4f459a6f11227487bc9baa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd75b4f8acb377559a26f159bbbba46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a3cd75b4f8acb377559a26f159bbbba46">Save</a> (const char *&amp;out_buf, size_t &amp;out_buf_size, <a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a> flags, Common::ProgressMonitor *progress)</td></tr>
<tr class="separator:a3cd75b4f8acb377559a26f159bbbba46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fdd033e3575e5d4d4c204e2f88de62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a56fdd033e3575e5d4d4c204e2f88de62">Save</a> (<a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a> &amp;stream, <a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a> flags)</td></tr>
<tr class="separator:a56fdd033e3575e5d4d4c204e2f88de62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3f96b2a8d7bdb46424c187ec9cf6a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a6d3f96b2a8d7bdb46424c187ec9cf6a2">SaveCustomSignature</a> (const <a class="el" href="namespacepdftron.html#a7bc90caf17b633a6832ec1e5162e1bc0">UChar</a> *in_signature, const size_t in_signature_size, const <a class="el" href="classpdftron_1_1_p_d_f_1_1_digital_signature_field.html">DigitalSignatureField</a> &amp;in_field, const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;in_path)</td></tr>
<tr class="separator:a6d3f96b2a8d7bdb46424c187ec9cf6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5f3cec8331848194261e482d38a840"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a2a5f3cec8331848194261e482d38a840">SaveCustomSignature</a> (const <a class="el" href="namespacepdftron.html#a7bc90caf17b633a6832ec1e5162e1bc0">UChar</a> *in_signature, const size_t in_signature_size, const <a class="el" href="classpdftron_1_1_p_d_f_1_1_digital_signature_field.html">DigitalSignatureField</a> &amp;in_field, <a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a> &amp;out_stream)</td></tr>
<tr class="separator:a2a5f3cec8331848194261e482d38a840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bd2789345a1bfd62e2dec8f1bde483"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#aa1bd2789345a1bfd62e2dec8f1bde483">SaveCustomSignature</a> (const <a class="el" href="namespacepdftron.html#a7bc90caf17b633a6832ec1e5162e1bc0">UChar</a> *in_signature, const size_t in_signature_size, const <a class="el" href="classpdftron_1_1_p_d_f_1_1_digital_signature_field.html">DigitalSignatureField</a> &amp;in_field, const <a class="el" href="namespacepdftron.html#a7bc90caf17b633a6832ec1e5162e1bc0">UChar</a> *&amp;out_buf, size_t &amp;out_buf_size)</td></tr>
<tr class="separator:aa1bd2789345a1bfd62e2dec8f1bde483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d15cf0c0510932ba886740f64952c91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepdftron_1_1_p_d_f.html#a5b4283a73763ea46351409cc9598ea66">PageIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a5d15cf0c0510932ba886740f64952c91">GetPageIterator</a> (<a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a> page_number=1)</td></tr>
<tr class="separator:a5d15cf0c0510932ba886740f64952c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c631eb201267494ce3e7c0025af1f79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a5c631eb201267494ce3e7c0025af1f79">GetPage</a> (<a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a> page_number)</td></tr>
<tr class="separator:a5c631eb201267494ce3e7c0025af1f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf8589d289d3fbae8a7f4139d48722e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#aedf8589d289d3fbae8a7f4139d48722e">PageRemove</a> (const <a class="el" href="namespacepdftron_1_1_p_d_f.html#a5b4283a73763ea46351409cc9598ea66">PageIterator</a> &amp;page_itr)</td></tr>
<tr class="separator:aedf8589d289d3fbae8a7f4139d48722e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebadf120389e86cfc8d532eda9dbd82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#abebadf120389e86cfc8d532eda9dbd82">PageInsert</a> (<a class="el" href="namespacepdftron_1_1_p_d_f.html#a5b4283a73763ea46351409cc9598ea66">PageIterator</a> &amp;where, <a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a> page)</td></tr>
<tr class="separator:abebadf120389e86cfc8d532eda9dbd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a75ca0e86e9fb587317e0d730c3b48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a91a75ca0e86e9fb587317e0d730c3b48">InsertPages</a> (int insert_before_page_number, <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;src_doc, int start_page, int end_page, enum <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ac43e9216b77ce9c7f52290f17bdbfc4d">InsertFlag</a> flag, Common::ProgressMonitor *monitor=0)</td></tr>
<tr class="separator:a91a75ca0e86e9fb587317e0d730c3b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565081b08450cb8d7e909a21cbe1fbb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a565081b08450cb8d7e909a21cbe1fbb0">InsertPages</a> (int insert_before_page_number, <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;src_doc, const <a class="el" href="classpdftron_1_1_p_d_f_1_1_page_set.html">PageSet</a> &amp;source_page_set, enum <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ac43e9216b77ce9c7f52290f17bdbfc4d">InsertFlag</a> flag, Common::ProgressMonitor *monitor=0)</td></tr>
<tr class="separator:a565081b08450cb8d7e909a21cbe1fbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f7d552487d82607564fa4095ed07da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#af3f7d552487d82607564fa4095ed07da">MovePages</a> (int move_before_page_number, <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;src_doc, int start_page, int end_page, enum <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ac43e9216b77ce9c7f52290f17bdbfc4d">InsertFlag</a> flag, Common::ProgressMonitor *monitor=0)</td></tr>
<tr class="separator:af3f7d552487d82607564fa4095ed07da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f57a974567e5e2d9d386540f397622e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a6f57a974567e5e2d9d386540f397622e">MovePages</a> (int move_before_page_number, <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;src_doc, const <a class="el" href="classpdftron_1_1_p_d_f_1_1_page_set.html">PageSet</a> &amp;source_page_set, enum <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ac43e9216b77ce9c7f52290f17bdbfc4d">InsertFlag</a> flag, Common::ProgressMonitor *monitor=0)</td></tr>
<tr class="separator:a6f57a974567e5e2d9d386540f397622e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad363a33ee80b44997f6aaed503041976"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ad363a33ee80b44997f6aaed503041976">PagePushFront</a> (<a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a> page)</td></tr>
<tr class="separator:ad363a33ee80b44997f6aaed503041976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b4e09872be651fe31145310281fa34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a20b4e09872be651fe31145310281fa34">PagePushBack</a> (<a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a> page)</td></tr>
<tr class="separator:a20b4e09872be651fe31145310281fa34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad230a2a036e1b8e999a7c1aafe145619"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ad230a2a036e1b8e999a7c1aafe145619">ImportPages</a> (const std::vector&lt; <a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a> &gt; &amp;pages, bool import_bookmarks=false)</td></tr>
<tr class="separator:ad230a2a036e1b8e999a7c1aafe145619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c8ed034327fc5e151bf626126e3623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a07c8ed034327fc5e151bf626126e3623">PageCreate</a> (const <a class="el" href="classpdftron_1_1_p_d_f_1_1_rect.html">Rect</a> &amp;media_box=<a class="el" href="classpdftron_1_1_p_d_f_1_1_rect.html">Rect</a>(0, 0, 612, 792))</td></tr>
<tr class="separator:a07c8ed034327fc5e151bf626126e3623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a557a4f6fbe35be88ef12ae2b43c322"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a2a557a4f6fbe35be88ef12ae2b43c322">AppendTextDiff</a> (<a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a> page1, <a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a> page2)</td></tr>
<tr class="separator:a2a557a4f6fbe35be88ef12ae2b43c322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946fcf44d5b50cba81cf299d2dd63883"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a946fcf44d5b50cba81cf299d2dd63883">AppendTextDiff</a> (<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;doc1, <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;doc2)</td></tr>
<tr class="separator:a946fcf44d5b50cba81cf299d2dd63883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37538873c844469c213c6ecd24eddda"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ad37538873c844469c213c6ecd24eddda">AppendTextDiff</a> (<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;doc1, <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;doc2, <a class="el" href="classpdftron_1_1_p_d_f_1_1_text_diff_options.html">TextDiffOptions</a> *options)</td></tr>
<tr class="separator:ad37538873c844469c213c6ecd24eddda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a55bd563a548b478492610b080ad10"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="classpdftron_1_1_p_d_f_1_1_bookmark.html">Bookmark</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a90a55bd563a548b478492610b080ad10">GetFirstBookmark</a> ()</td></tr>
<tr class="separator:a90a55bd563a548b478492610b080ad10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cdc9b146092c4a6089bcabccab8c8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ab4cdc9b146092c4a6089bcabccab8c8e">AddRootBookmark</a> (class <a class="el" href="classpdftron_1_1_p_d_f_1_1_bookmark.html">Bookmark</a> root_bookmark)</td></tr>
<tr class="separator:ab4cdc9b146092c4a6089bcabccab8c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e8ceb8178e032c2ae1c6a80453d3c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a32e8ceb8178e032c2ae1c6a80453d3c6">GetTrailer</a> ()</td></tr>
<tr class="separator:a32e8ceb8178e032c2ae1c6a80453d3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae644be52ed8fdd52711c6186a7f644dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ae644be52ed8fdd52711c6186a7f644dd">GetRoot</a> ()</td></tr>
<tr class="separator:ae644be52ed8fdd52711c6186a7f644dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fffdd194185d2253a063e5fe457c29f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a0fffdd194185d2253a063e5fe457c29f">GetPages</a> ()</td></tr>
<tr class="separator:a0fffdd194185d2253a063e5fe457c29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d0cd1a5e1dcb68ff92552b5ae621be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a03d0cd1a5e1dcb68ff92552b5ae621be">GetPageCount</a> ()</td></tr>
<tr class="separator:a03d0cd1a5e1dcb68ff92552b5ae621be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345c0faef5043a1f9f249fc27c7711f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepdftron_1_1_p_d_f.html#af5da72315f20771f76f3a109ce43b941">FieldIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a345c0faef5043a1f9f249fc27c7711f2">GetFieldIterator</a> ()</td></tr>
<tr class="separator:a345c0faef5043a1f9f249fc27c7711f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8a89c45419c85d3cc08bc744d89db1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepdftron_1_1_p_d_f.html#af5da72315f20771f76f3a109ce43b941">FieldIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a8e8a89c45419c85d3cc08bc744d89db1">GetFieldIterator</a> (const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;field_name)</td></tr>
<tr class="separator:a8e8a89c45419c85d3cc08bc744d89db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69428d0409071aadd112c231b25eb3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html">Field</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ac69428d0409071aadd112c231b25eb3c">GetField</a> (const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;field_name)</td></tr>
<tr class="separator:ac69428d0409071aadd112c231b25eb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecbe75cf2739a18cac08090d8fe972b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html">Field</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#afecbe75cf2739a18cac08090d8fe972b">FieldCreate</a> (const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;field_name, <a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html#ad5998483c479a65c6e022075f4adb2a3">Field::Type</a> type, <a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> field_value=0, <a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> def_field_value=0)</td></tr>
<tr class="separator:afecbe75cf2739a18cac08090d8fe972b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804cf67bb184a5fc4d5a8ed96e99c094"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html">Field</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a804cf67bb184a5fc4d5a8ed96e99c094">FieldCreate</a> (const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;field_name, <a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html#ad5998483c479a65c6e022075f4adb2a3">Field::Type</a> type, const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;field_value, const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;def_field_value=&quot;&quot;)</td></tr>
<tr class="separator:a804cf67bb184a5fc4d5a8ed96e99c094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497139a384bd6fcb864f11e39b3f22db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a497139a384bd6fcb864f11e39b3f22db">RefreshFieldAppearances</a> ()</td></tr>
<tr class="separator:a497139a384bd6fcb864f11e39b3f22db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f1847c93cb4847c5feb15636d4259f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#af3f1847c93cb4847c5feb15636d4259f">RefreshAnnotAppearances</a> (const <a class="el" href="classpdftron_1_1_p_d_f_1_1_refresh_options.html">RefreshOptions</a> *options=0)</td></tr>
<tr class="separator:af3f1847c93cb4847c5feb15636d4259f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ba369da0b667e703116d96b3ed06b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ab5ba369da0b667e703116d96b3ed06b9">FlattenAnnotations</a> (bool forms_only=false)</td></tr>
<tr class="separator:ab5ba369da0b667e703116d96b3ed06b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af924f9293105e3017f5e0b50122f1f5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#af924f9293105e3017f5e0b50122f1f5e">GetAcroForm</a> ()</td></tr>
<tr class="separator:af924f9293105e3017f5e0b50122f1f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa6e0cfc68668edaffe0a177fce39fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_f_d_f_1_1_f_d_f_doc.html">FDF::FDFDoc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#adaa6e0cfc68668edaffe0a177fce39fa">FDFExtract</a> (enum <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7967f365a4c14369836db9c3a43d4163">ExtractFlag</a> flag=<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7967f365a4c14369836db9c3a43d4163ac76092a7e88aace0b2e947b27df9bc4a">e_forms_only</a>)</td></tr>
<tr class="separator:adaa6e0cfc68668edaffe0a177fce39fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1fb3485b40bcfa6388d0fb24b80ea3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_f_d_f_1_1_f_d_f_doc.html">FDF::FDFDoc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#acf1fb3485b40bcfa6388d0fb24b80ea3">FDFExtract</a> (<a class="el" href="classpdftron_1_1_p_d_f_1_1_page_set.html">PageSet</a> &amp;pages_to_extract, enum <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7967f365a4c14369836db9c3a43d4163">ExtractFlag</a> flag=<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7967f365a4c14369836db9c3a43d4163ac76092a7e88aace0b2e947b27df9bc4a">e_forms_only</a>)</td></tr>
<tr class="separator:acf1fb3485b40bcfa6388d0fb24b80ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1535535bc64f213394a5e7883f153a4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_f_d_f_1_1_f_d_f_doc.html">FDF::FDFDoc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a1535535bc64f213394a5e7883f153a4e">FDFExtract</a> (const std::vector&lt; <a class="el" href="classpdftron_1_1_p_d_f_1_1_annot.html">Annot</a> &gt; &amp;annotations)</td></tr>
<tr class="separator:a1535535bc64f213394a5e7883f153a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc8390ff326c4cf743bb4e0ff7c65c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_f_d_f_1_1_f_d_f_doc.html">FDF::FDFDoc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#accc8390ff326c4cf743bb4e0ff7c65c0">FDFExtract</a> (const std::vector&lt; <a class="el" href="classpdftron_1_1_p_d_f_1_1_annot.html">Annot</a> &gt; &amp;annot_added, const std::vector&lt; <a class="el" href="classpdftron_1_1_p_d_f_1_1_annot.html">Annot</a> &gt; &amp;annot_modified, const std::vector&lt; <a class="el" href="classpdftron_1_1_p_d_f_1_1_annot.html">Annot</a> &gt; &amp;annot_deleted)</td></tr>
<tr class="separator:accc8390ff326c4cf743bb4e0ff7c65c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fd9c9711fc5660acae0c5feba5ccf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ac2fd9c9711fc5660acae0c5feba5ccf1">FDFMerge</a> (<a class="el" href="classpdftron_1_1_f_d_f_1_1_f_d_f_doc.html">FDF::FDFDoc</a> &amp;fdf_doc)</td></tr>
<tr class="separator:ac2fd9c9711fc5660acae0c5feba5ccf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5f655f8ab7f694c20b357503f8f17b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a3e5f655f8ab7f694c20b357503f8f17b">FDFUpdate</a> (<a class="el" href="classpdftron_1_1_f_d_f_1_1_f_d_f_doc.html">FDF::FDFDoc</a> &amp;fdf_doc)</td></tr>
<tr class="separator:a3e5f655f8ab7f694c20b357503f8f17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3416f3730763a856346092edb8a80cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_p_d_f_1_1_action.html">Action</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ab3416f3730763a856346092edb8a80cf">GetOpenAction</a> ()</td></tr>
<tr class="separator:ab3416f3730763a856346092edb8a80cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaaf66bca8fcb4e7506b234ca05eba7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7eaaf66bca8fcb4e7506b234ca05eba7">SetOpenAction</a> (const <a class="el" href="classpdftron_1_1_p_d_f_1_1_action.html">Action</a> &amp;action)</td></tr>
<tr class="separator:a7eaaf66bca8fcb4e7506b234ca05eba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741256c353945d6b0d8fbba3d8e97a11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a741256c353945d6b0d8fbba3d8e97a11">AddFileAttachment</a> (const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;file_key, <a class="el" href="classpdftron_1_1_p_d_f_1_1_file_spec.html">FileSpec</a> embedded_file)</td></tr>
<tr class="separator:a741256c353945d6b0d8fbba3d8e97a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4720ab712a9049f845f0947ac495302e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_p_d_f_1_1_page_label.html">PageLabel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a4720ab712a9049f845f0947ac495302e">GetPageLabel</a> (int page_num)</td></tr>
<tr class="separator:a4720ab712a9049f845f0947ac495302e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767edcf05ae465cce44a720a73163658"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a767edcf05ae465cce44a720a73163658">SetPageLabel</a> (int page_num, <a class="el" href="classpdftron_1_1_p_d_f_1_1_page_label.html">PageLabel</a> &amp;label)</td></tr>
<tr class="separator:a767edcf05ae465cce44a720a73163658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1d9d6ca294791c44e2f4527ab138bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a0e1d9d6ca294791c44e2f4527ab138bc">RemovePageLabel</a> (int page_num)</td></tr>
<tr class="separator:a0e1d9d6ca294791c44e2f4527ab138bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cbff86d5df038add391c09a978a39e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ac1cbff86d5df038add391c09a978a39e">IsTagged</a> ()</td></tr>
<tr class="separator:ac1cbff86d5df038add391c09a978a39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874cc47e1b0b28378ab63eeae30e1266"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_p_d_f_1_1_struct_1_1_s_tree.html">Struct::STree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a874cc47e1b0b28378ab63eeae30e1266">GetStructTree</a> ()</td></tr>
<tr class="separator:a874cc47e1b0b28378ab63eeae30e1266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a8ee81c1a018b7730f47d6d1e5c9df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ae2a8ee81c1a018b7730f47d6d1e5c9df">HasOC</a> () const </td></tr>
<tr class="separator:ae2a8ee81c1a018b7730f47d6d1e5c9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716ea1550ffd6c6de6fc26c0ed019c2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a716ea1550ffd6c6de6fc26c0ed019c2f">GetOCGs</a> () const </td></tr>
<tr class="separator:a716ea1550ffd6c6de6fc26c0ed019c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dad92927363622267398b640219aafb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_p_d_f_1_1_o_c_g_1_1_config.html">OCG::Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a9dad92927363622267398b640219aafb">GetOCGConfig</a> () const </td></tr>
<tr class="separator:a9dad92927363622267398b640219aafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554f185b58f7e947fc9fe507d86c3494"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a554f185b58f7e947fc9fe507d86c3494">AddHighlights</a> (const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;hilite)</td></tr>
<tr class="separator:a554f185b58f7e947fc9fe507d86c3494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1317fc9c8a4835a9a9a30a1b6bd44b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a6b1317fc9c8a4835a9a9a30a1b6bd44b">CreateIndirectName</a> (const char *name)</td></tr>
<tr class="separator:a6b1317fc9c8a4835a9a9a30a1b6bd44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879ce5f2c8bb9ed63575cc200893bdaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a879ce5f2c8bb9ed63575cc200893bdaa">CreateIndirectArray</a> ()</td></tr>
<tr class="separator:a879ce5f2c8bb9ed63575cc200893bdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bcefc92b483d700eb8073aa5c4c251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a78bcefc92b483d700eb8073aa5c4c251">CreateIndirectBool</a> (bool value)</td></tr>
<tr class="separator:a78bcefc92b483d700eb8073aa5c4c251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb2a4a29f3daf2d05bc95c7aa8e61b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a5eb2a4a29f3daf2d05bc95c7aa8e61b9">CreateIndirectDict</a> ()</td></tr>
<tr class="separator:a5eb2a4a29f3daf2d05bc95c7aa8e61b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab37bf4e67c43e91bf4b981846575f82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#aab37bf4e67c43e91bf4b981846575f82">CreateIndirectNull</a> ()</td></tr>
<tr class="separator:aab37bf4e67c43e91bf4b981846575f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74624481f0e15aaaaaa62ef0eaf0443"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ae74624481f0e15aaaaaa62ef0eaf0443">CreateIndirectNumber</a> (double value)</td></tr>
<tr class="separator:ae74624481f0e15aaaaaa62ef0eaf0443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c40391685d5c3f0581b6340edad42e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a61c40391685d5c3f0581b6340edad42e">CreateIndirectString</a> (const <a class="el" href="namespacepdftron.html#a7bc90caf17b633a6832ec1e5162e1bc0">UChar</a> *value, <a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a> size)</td></tr>
<tr class="separator:a61c40391685d5c3f0581b6340edad42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c13eb519ae28730a641c07f9f98eb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#aa6c13eb519ae28730a641c07f9f98eb3">CreateIndirectString</a> (const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;str)</td></tr>
<tr class="separator:aa6c13eb519ae28730a641c07f9f98eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b7106838d84e465e85b601ce5523ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a49b7106838d84e465e85b601ce5523ff">CreateIndirectStream</a> (<a class="el" href="classpdftron_1_1_filters_1_1_filter_reader.html">Filters::FilterReader</a> &amp;data, <a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a> filter_chain=<a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a>(0, false))</td></tr>
<tr class="separator:a49b7106838d84e465e85b601ce5523ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813a283e02b03e125bb44887c944894d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a813a283e02b03e125bb44887c944894d">CreateIndirectStream</a> (const char *data, const size_t data_size, <a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a> filter_chain=<a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a>(0, false))</td></tr>
<tr class="separator:a813a283e02b03e125bb44887c944894d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af119c1bd1c5c9e9185c6c2a1a97329a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDF::SDFDoc</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#af119c1bd1c5c9e9185c6c2a1a97329a9">GetSDFDoc</a> ()</td></tr>
<tr class="separator:af119c1bd1c5c9e9185c6c2a1a97329a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3167b167a9cdd5d5454b6216847196c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#af3167b167a9cdd5d5454b6216847196c">operator SDF::SDFDoc &amp;</a> ()</td></tr>
<tr class="separator:af3167b167a9cdd5d5454b6216847196c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4d84e5af00585b8b4763fc06c95a95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a5e4d84e5af00585b8b4763fc06c95a95">Lock</a> ()</td></tr>
<tr class="separator:a5e4d84e5af00585b8b4763fc06c95a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bd0fee07a1ee1e3ce12b0b800d3f5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ab1bd0fee07a1ee1e3ce12b0b800d3f5b">Unlock</a> ()</td></tr>
<tr class="separator:ab1bd0fee07a1ee1e3ce12b0b800d3f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0937b6595b48f8383dfe2f24d0a1c272"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a0937b6595b48f8383dfe2f24d0a1c272">TryLock</a> (int milliseconds=0)</td></tr>
<tr class="separator:a0937b6595b48f8383dfe2f24d0a1c272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7379968d42005593f9de5d4bf695cdd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7379968d42005593f9de5d4bf695cdd8">LockRead</a> ()</td></tr>
<tr class="separator:a7379968d42005593f9de5d4bf695cdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61179c7ae9f00d9cc7c2e1ee67c5d79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#aa61179c7ae9f00d9cc7c2e1ee67c5d79">UnlockRead</a> ()</td></tr>
<tr class="separator:aa61179c7ae9f00d9cc7c2e1ee67c5d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a3f63b8585ddee9db9cde87335f1ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a71a3f63b8585ddee9db9cde87335f1ea">TryLockRead</a> (int milliseconds=0)</td></tr>
<tr class="separator:a71a3f63b8585ddee9db9cde87335f1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93bd0070c427c27682de25b4fa34bdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_u_string.html">UString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ae93bd0070c427c27682de25b4fa34bdd">GetFileName</a> () const </td></tr>
<tr class="separator:ae93bd0070c427c27682de25b4fa34bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2f659eff64463a0650d2cd188d65ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#abd2f659eff64463a0650d2cd188d65ef">GenerateThumbnails</a> (<a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a> size)</td></tr>
<tr class="separator:abd2f659eff64463a0650d2cd188d65ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08070ec3ba296644c5077e030601b061"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a08070ec3ba296644c5077e030601b061">AppendVisualDiff</a> (<a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a> p1, <a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a> p2, <a class="el" href="classpdftron_1_1_p_d_f_1_1_diff_options.html">DiffOptions</a> *opts)</td></tr>
<tr class="separator:a08070ec3ba296644c5077e030601b061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7e2bd020ac646b8e629c75f7fdd4d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#abc7e2bd020ac646b8e629c75f7fdd4d3">SaveViewerOptimized</a> (const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;path, const <a class="el" href="classpdftron_1_1_p_d_f_1_1_viewer_optimized_options.html">ViewerOptimizedOptions</a> &amp;opts)</td></tr>
<tr class="separator:abc7e2bd020ac646b8e629c75f7fdd4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac2dd0afb5c44e721dca7878702a92b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#acac2dd0afb5c44e721dca7878702a92b">SaveViewerOptimized</a> (const char *&amp;out_buf, size_t &amp;out_buf_size, const <a class="el" href="classpdftron_1_1_p_d_f_1_1_viewer_optimized_options.html">ViewerOptimizedOptions</a> &amp;opts)</td></tr>
<tr class="separator:acac2dd0afb5c44e721dca7878702a92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3fa14be9f5a511f141620f1946852e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#acb06ed1ead06ee4cb4f383b3d655ee59">SignaturesVerificationStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ade3fa14be9f5a511f141620f1946852e">VerifySignedDigitalSignatures</a> (const <a class="el" href="classpdftron_1_1_p_d_f_1_1_verification_options.html">VerificationOptions</a> &amp;in_opts) const </td></tr>
<tr class="separator:ade3fa14be9f5a511f141620f1946852e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dd9750f64f1962f1e288b7719c296d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a91dd9750f64f1962f1e288b7719c296d">MergeXFDF</a> (<a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a> stream, const <a class="el" href="classpdftron_1_1_p_d_f_1_1_merge_x_f_d_f_options.html">MergeXFDFOptions</a> *opts=0)</td></tr>
<tr class="separator:a91dd9750f64f1962f1e288b7719c296d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18e13f3299e4b32dcbc868e62b4be76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ae18e13f3299e4b32dcbc868e62b4be76">MergeXFDF</a> (const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;xfdf, const <a class="el" href="classpdftron_1_1_p_d_f_1_1_merge_x_f_d_f_options.html">MergeXFDFOptions</a> *opts=0)</td></tr>
<tr class="separator:ae18e13f3299e4b32dcbc868e62b4be76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdee56173d66893c7cf3db144c3e0f1"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a5bdee56173d66893c7cf3db144c3e0f1">GetHandleInternal</a> ()</td></tr>
<tr class="separator:a5bdee56173d66893c7cf3db144c3e0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a160351aee694729669b0514b75ef4251"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a160351aee694729669b0514b75ef4251">HighlightTextDiff</a> (<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;doc1, <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;doc2, <a class="el" href="classpdftron_1_1_p_d_f_1_1_text_diff_options.html">TextDiffOptions</a> *options)</td></tr>
<tr class="separator:a160351aee694729669b0514b75ef4251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5579459d83643e24ba7dcb9376248a9e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a5579459d83643e24ba7dcb9376248a9e">CreateInternal</a> (ptrdiff_t impl)</td></tr>
<tr class="separator:a5579459d83643e24ba7dcb9376248a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> is a high-level class describing a single <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> (Portable Document Format) document. Most applications using <a class="el" href="classpdftron_1_1_p_d_f_net.html">PDFNet</a> will use this class to open existing <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> documents, or to create new <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> documents from scratch.</p>
<p>The class offers a number of entry points into the document. For example,</p>
<ul>
<li>To access pages use pdfdoc.GetPageIterator() or pdfdoc.GetPage(page_num).</li>
<li>To access form fields use pdfdoc.GetFieldIterator(), pdfdoc.GetFieldIterator(name) or pdfdoc.GetField(name).</li>
<li>To access document's meta-data use pdfdoc.GetDocInfo().</li>
<li>To access the outline tree use pdfdoc.GetFirstBookmark().</li>
<li>To access low-level Document Catalog use pdfdoc.GetRoot(). ...</li>
</ul>
<p>The class also offers utility methods to slit and merge <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> pages, to create new pages, to flatten forms, to change security settings, etc. </p>

<p>Definition at line <a class="el" href="_p_d_f_doc_8h_source.html#l00070">70</a> of file <a class="el" href="_p_d_f_doc_8h_source.html">PDFDoc.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a17d1f00bcaf9272f316b2bd0adc28cb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a17d1f00bcaf9272f316b2bd0adc28cb5">pdftron::PDF::PDFDoc::ActionTriggerEvent</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a17d1f00bcaf9272f316b2bd0adc28cb5a5b61782e5cb569c3192183a074707ea6"></a>e_action_trigger_doc_will_close</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a17d1f00bcaf9272f316b2bd0adc28cb5a0a98a3b87fa034e653b8d6087fd1f94d"></a>e_action_trigger_doc_will_save</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a17d1f00bcaf9272f316b2bd0adc28cb5a615d2500089a4cbd2a4d0b940893f9de"></a>e_action_trigger_doc_did_save</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a17d1f00bcaf9272f316b2bd0adc28cb5af4ea663a8f0509d9d3d96b7ed39de17f"></a>e_action_trigger_doc_will_print</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a17d1f00bcaf9272f316b2bd0adc28cb5a2d81136d09f77d9c095b24e8a62da7e7"></a>e_action_trigger_doc_did_print</em>&nbsp;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_p_d_f_doc_8h_source.html#l00405">405</a> of file <a class="el" href="_p_d_f_doc_8h_source.html">PDFDoc.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7967f365a4c14369836db9c3a43d4163"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7967f365a4c14369836db9c3a43d4163">pdftron::PDF::PDFDoc::ExtractFlag</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a7967f365a4c14369836db9c3a43d4163ac76092a7e88aace0b2e947b27df9bc4a"></a>e_forms_only</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7967f365a4c14369836db9c3a43d4163a98b7b5a30657ed23ec4b624794a3aada"></a>e_annots_only</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7967f365a4c14369836db9c3a43d4163a989e4866df6de947a70696a4d66b233a"></a>e_both</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7967f365a4c14369836db9c3a43d4163a2aeb8b12269c00bef7db09906a655cb6"></a>e_annots_only_no_links</em>&nbsp;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_p_d_f_doc_8h_source.html#l01109">1109</a> of file <a class="el" href="_p_d_f_doc_8h_source.html">PDFDoc.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac43e9216b77ce9c7f52290f17bdbfc4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ac43e9216b77ce9c7f52290f17bdbfc4d">pdftron::PDF::PDFDoc::InsertFlag</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ac43e9216b77ce9c7f52290f17bdbfc4dad780b7aba1fa38ff9aaeb5a4f50accb2"></a>e_none</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac43e9216b77ce9c7f52290f17bdbfc4da8e56f3c4c6460c92b393b3ef17d35540"></a>e_insert_bookmark</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac43e9216b77ce9c7f52290f17bdbfc4da44ba9cf9fdac1c70db9b15fbcafd7a02"></a>e_insert_goto_bookmark</em>&nbsp;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_p_d_f_doc_8h_source.html#l00690">690</a> of file <a class="el" href="_p_d_f_doc_8h_source.html">PDFDoc.h</a>.</p>

</div>
</div>
<a class="anchor" id="acb06ed1ead06ee4cb4f383b3d655ee59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#acb06ed1ead06ee4cb4f383b3d655ee59">pdftron::PDF::PDFDoc::SignaturesVerificationStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="acb06ed1ead06ee4cb4f383b3d655ee59ac795b15d37d4e1a0944a34b15669a10b"></a>e_unsigned</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acb06ed1ead06ee4cb4f383b3d655ee59ae3569e6beef10560ad16f2da9ead3102"></a>e_failure</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acb06ed1ead06ee4cb4f383b3d655ee59a80637e5489e042b80010e8522be6f3fd"></a>e_untrusted</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acb06ed1ead06ee4cb4f383b3d655ee59aa92409b7bcdbf04360001e328ce9f9a9"></a>e_unsupported</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acb06ed1ead06ee4cb4f383b3d655ee59a588b4e452d46118346d74739a3b2c233"></a>e_verified</em>&nbsp;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_p_d_f_doc_8h_source.html#l01480">1480</a> of file <a class="el" href="_p_d_f_doc_8h_source.html">PDFDoc.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4ae987ae6a379949e5beeb3f30182852"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pdftron::PDF::PDFDoc::PDFDoc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Creates an empty new document. </p>

</div>
</div>
<a class="anchor" id="af0a46ca7bfdf7998d304d5b2251c014a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pdftron::PDF::PDFDoc::PDFDoc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDF::SDFDoc</a> &amp;&#160;</td>
          <td class="paramname"><em>sdfdoc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> document from an existing SDF/Cos document.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdfdoc</td><td>a pointer to the <a class="el" href="namespacepdftron_1_1_s_d_f.html">SDF</a> document. Created <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> will take the ownership of the low-level document.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the SDFDoc will become invalid. If you would like to access the low level document use GetSDFDoc </dd></dl>

</div>
</div>
<a class="anchor" id="a61703e97010ccb0b4f642cc062aed66d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pdftron::PDF::PDFDoc::PDFDoc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a shallow copy of another <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>a reference to the <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> document to clone. Created <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> will retain a reference to the same low-level document as the source. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01413dce319bc93dd6eced5077d435a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pdftron::PDF::PDFDoc::PDFDoc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open an existing <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> document</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>- pathname to the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Make sure to call <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#adc0d28e22efa7856249874012a81d4fe">InitSecurityHandler()</a> after <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a>(...) in case a document is encrypted </dd></dl>

</div>
</div>
<a class="anchor" id="a82ef303f66bf212280dc82be2573fa17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pdftron::PDF::PDFDoc::PDFDoc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acece1703ff2d7b6cd85fb0e52c0e72c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pdftron::PDF::PDFDoc::PDFDoc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a>&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open an existing <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> document</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>- input stream containing a serialized document. The input stream may be a random-access file, memory buffer, slow HTTP connection etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>if the input stream doesn't support Seek() operation the document will load whole data stream in memory before parsing. In case of linearized <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a>, the document may be parsed on-the-fly while it is being loaded in memory. Note that since MappedFile implements Seek() interface, the document does not have to be fully in memory before it is used.</dd>
<dd>
Make sure to call <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#adc0d28e22efa7856249874012a81d4fe">InitSecurityHandler()</a> after <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a>(...) for encrypted documents. </dd>
<dd>
<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> takes the ownership of the stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f1e6bd9ad0037bcacc59744855a2c0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pdftron::PDF::PDFDoc::PDFDoc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepdftron.html#a7bc90caf17b633a6832ec1e5162e1bc0">UChar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a SDF/Cos document from a memory buffer. </p>
<dl class="section note"><dt>Note</dt><dd>the document should be fully loaded in the memory buffer. </dd>
<dd>
the buffer ownership is not transfered to the document so the user should clean-up any allocated memory if necessary.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>- a memory buffer containing the serialized document </td></tr>
    <tr><td class="paramname">buf_size</td><td>- the size of memory buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7719c185b93542c5bee4592c871ce83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pdftron::PDF::PDFDoc::~PDFDoc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a741256c353945d6b0d8fbba3d8e97a11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::AddFileAttachment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>file_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_file_spec.html">FileSpec</a>&#160;</td>
          <td class="paramname"><em>embedded_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Associates a file attachment with the document.</p>
<p>The file attachment will be displayed in the user interface of a viewer application (in Acrobat this is File Attachment tab). The function differs from Annot.CreateFileAttachment() because it associates the attachment with the whole document instead of an annotation on a specific page.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_key</td><td>A key/name under which the attachment will be stored. </td></tr>
    <tr><td class="paramname">embedded_file</td><td>Embedded file stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Another way to associate a file attachment with the document is using <a class="el" href="classpdftron_1_1_s_d_f_1_1_name_tree.html">SDF::NameTree</a>: <div class="fragment"><div class="line">*   SDF::NameTree names = <a class="code" href="classpdftron_1_1_s_d_f_1_1_name_tree.html#a1cc51f496355353b9372bb22c0a9c9e2">SDF::NameTree::Create</a>(doc, <span class="stringliteral">&quot;EmbeddedFiles&quot;</span>);</div>
<div class="line">*   names.Put(file_key, file_keysz, embedded_file.GetSDFObj());</div>
<div class="line">* </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a554f185b58f7e947fc9fe507d86c3494"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::AddHighlights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>hilite</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>AddHighlights is used to highlight text in a document using 'Adobe's <a class="el" href="structpdftron_1_1_p_d_f_1_1_highlight.html">Highlight</a> File Format' (Technical Note #5172 ). The method will parse the character offset data and modify the current document by adding new highlight annotations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hilite</td><td>a string representing the filename for the highlight file or or a data buffer containing XML data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">An</td><td>exception will be thrown if the XML file is malformed or os out of sync with the document. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4cdc9b146092c4a6089bcabccab8c8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::AddRootBookmark </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="classpdftron_1_1_p_d_f_1_1_bookmark.html">Bookmark</a>&#160;</td>
          <td class="paramname"><em>root_bookmark</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds/links the specified <a class="el" href="classpdftron_1_1_p_d_f_1_1_bookmark.html">Bookmark</a> to the root level of document's outline tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_bookmark</td><td><a class="el" href="classpdftron_1_1_p_d_f_1_1_bookmark.html">Bookmark</a> to Add/link </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>parameter 'root_bookmark' must not be linked (must not be belong) to a bookmark tree. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ca4b550724a5c605876f1ac0b148640"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepdftron_1_1_s_d_f.html#a38b73540250fd07f741bbe4fba66634a">SDF::SignatureHandlerId</a> pdftron::PDF::PDFDoc::AddSignatureHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_s_d_f_1_1_signature_handler.html">SDF::SignatureHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>signature_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a signature handler to the signature manager.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signature_handler</td><td>The signature handler instance to add to the signature manager.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique ID representing the SignatureHandler within the SignatureManager. </dd></dl>

</div>
</div>
<a class="anchor" id="a75d017a37d0aea3c70c3adfe65db3e49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepdftron_1_1_s_d_f.html#a38b73540250fd07f741bbe4fba66634a">SDF::SignatureHandlerId</a> pdftron::PDF::PDFDoc::AddStdSignatureHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>pkcs12_keyfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>pkcs12_keypass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a standard (built-in) signature handler to the signature manager. This method will use cryptographic algorithm based on Adobe.PPKLite/adbe.pkcs7.detached filter to sign a <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkcs12_file</td><td>The private key certificate store to use. </td></tr>
    <tr><td class="paramname">pkcs12_pass</td><td>The passphrase for the provided private key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique ID representing the SignatureHandler within the SignatureManager. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2120a611f4d61cbff50f3411e9f4781"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepdftron_1_1_s_d_f.html#a38b73540250fd07f741bbe4fba66634a">SDF::SignatureHandlerId</a> pdftron::PDF::PDFDoc::AddStdSignatureHandler </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>pkcs12_keybuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>pkcs12_keypass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a standard (built-in) signature handler to the signature manager. This method will use cryptographic algorithm based on Adobe.PPKLite/adbe.pkcs7.detached filter to sign a <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkcs12_keybuffer</td><td>The private key certificate store to use (as a data buffer in an array of bytes). </td></tr>
    <tr><td class="paramname">pkcs12_pass</td><td>The passphrase for the provided private key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique ID representing the SignatureHandler within the SignatureManager. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a557a4f6fbe35be88ef12ae2b43c322"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pdftron::PDF::PDFDoc::AppendTextDiff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a>&#160;</td>
          <td class="paramname"><em>page1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a>&#160;</td>
          <td class="paramname"><em>page2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Imports two external pages and highlights the differences between them. This function adds two new pages to the current document. The two input pages are typically coming from two different <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> files. Note: Each contiguous block of change is considered a single difference. A deletion immediately followed by an insertion is considered a single edit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page1</td><td>is the before page, the basis of the comparison (read-only) </td></tr>
    <tr><td class="paramname">page2</td><td>is the after page, to which the basis is compared (read-only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of differences found </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is beta and is subject to change </dd></dl>

</div>
</div>
<a class="anchor" id="a946fcf44d5b50cba81cf299d2dd63883"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pdftron::PDF::PDFDoc::AppendTextDiff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;&#160;</td>
          <td class="paramname"><em>doc1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;&#160;</td>
          <td class="paramname"><em>doc2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Imports two external PDFs and highlights the differences between them. This function appends alternating pages from the two input documents into the current document. Note: Each contiguous block of change is considered a single difference. A deletion immediately followed by an insertion is considered a single edit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doc1</td><td>is the before document, the basis of the comparison (read-only) </td></tr>
    <tr><td class="paramname">doc2</td><td>is the after document, to which the basis is compared (read-only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of differences found </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is beta and is subject to change </dd></dl>

</div>
</div>
<a class="anchor" id="ad37538873c844469c213c6ecd24eddda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pdftron::PDF::PDFDoc::AppendTextDiff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;&#160;</td>
          <td class="paramname"><em>doc1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;&#160;</td>
          <td class="paramname"><em>doc2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_text_diff_options.html">TextDiffOptions</a> *&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Imports two external PDFs and highlights the differences between them. This function appends alternating pages from the two input documents into the current document. Note: Each contiguous block of change is considered a single difference. A deletion immediately followed by an insertion is considered a single edit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doc1</td><td>is the before document, the basis of the comparison (read-only) </td></tr>
    <tr><td class="paramname">doc2</td><td>is the after document, to which the basis is compared (read-only) </td></tr>
    <tr><td class="paramname">options</td><td>processing options (optional) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of differences found </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is beta and is subject to change </dd></dl>

</div>
</div>
<a class="anchor" id="a08070ec3ba296644c5077e030601b061"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::AppendVisualDiff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a>&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_diff_options.html">DiffOptions</a> *&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> diff of the given pages by overlaying and blending them on top of each other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>one of the two pages for comparing. </td></tr>
    <tr><td class="paramname">p2</td><td>the other page for comparing. </td></tr>
    <tr><td class="paramname">opts</td><td>options for comparison results. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a511fad638795208aaf0f4401b7c2b926"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::Close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> </p>

</div>
</div>
<a class="anchor" id="a26de22e1354fa0f4cc5ce5b49cb0efbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_p_d_f_1_1_digital_signature_field.html">PDF::DigitalSignatureField</a> pdftron::PDF::PDFDoc::CreateDigitalSignatureField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>in_sig_field_name</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an unsigned digital signature form field inside the document.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_sig_field_name</td><td>The fully-qualified name to give the digital signature field. If one is not provided, a unique name is created automatically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classpdftron_1_1_p_d_f_1_1_digital_signature_field.html">DigitalSignatureField</a> object representing the created digital signature field. </dd></dl>

</div>
</div>
<a class="anchor" id="a879ce5f2c8bb9ed63575cc200893bdaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> pdftron::PDF::PDFDoc::CreateIndirectArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method creates an SDF/Cos indirect array object</p>
<p>Unlike direct objects, indirect objects can be referenced by more than one object (i.e. indirect objects can be shared). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a new indirect array object. </dd></dl>

</div>
</div>
<a class="anchor" id="a78bcefc92b483d700eb8073aa5c4c251"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> pdftron::PDF::PDFDoc::CreateIndirectBool </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method creates an SDF/Cos indirect boolean object</p>
<p>Unlike direct objects, indirect objects can be referenced by more than one object (i.e. indirect objects can be shared). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a new indirect boolean object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value with which to create the boolean object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5eb2a4a29f3daf2d05bc95c7aa8e61b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> pdftron::PDF::PDFDoc::CreateIndirectDict </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method creates an SDF/Cos indirect dict object</p>
<p>Unlike direct objects, indirect objects can be referenced by more than one object (i.e. indirect objects can be shared). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a new indirect dict object. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b1317fc9c8a4835a9a9a30a1b6bd44b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> pdftron::PDF::PDFDoc::CreateIndirectName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method creates an SDF/Cos indirect name object</p>
<p>Unlike direct objects, indirect objects can be referenced by more than one object (i.e. indirect objects can be shared). </p>

</div>
</div>
<a class="anchor" id="aab37bf4e67c43e91bf4b981846575f82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> pdftron::PDF::PDFDoc::CreateIndirectNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method creates an SDF/Cos indirect null object</p>
<p>Unlike direct objects, indirect objects can be referenced by more than one object (i.e. indirect objects can be shared). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a new indirect null object. </dd></dl>

</div>
</div>
<a class="anchor" id="ae74624481f0e15aaaaaa62ef0eaf0443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> pdftron::PDF::PDFDoc::CreateIndirectNumber </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method creates an SDF/Cos indirect number object</p>
<p>Unlike direct objects, indirect objects can be referenced by more than one object (i.e. indirect objects can be shared). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a new indirect number object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value with which to create the number object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49b7106838d84e465e85b601ce5523ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> pdftron::PDF::PDFDoc::CreateIndirectStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_filters_1_1_filter_reader.html">Filters::FilterReader</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a>&#160;</td>
          <td class="paramname"><em>filter_chain</em> = <code><a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a>(0,&#160;false)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method creates an SDF/Cos indirect stream object</p>
<p>Unlike direct objects, indirect objects can be referenced by more than one object (i.e. indirect objects can be shared). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a new indirect stream object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>reference to a FilterReader object with which to create the stream object. </td></tr>
    <tr><td class="paramname">filter_chain</td><td>filter object with which to create the stream object. Defaults to Filters::Filter(0,false) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a813a283e02b03e125bb44887c944894d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> pdftron::PDF::PDFDoc::CreateIndirectStream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a>&#160;</td>
          <td class="paramname"><em>filter_chain</em> = <code><a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a>(0,&#160;false)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method creates an SDF/Cos indirect stream object</p>
<p>Unlike direct objects, indirect objects can be referenced by more than one object (i.e. indirect objects can be shared). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a new indirect stream object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>a buffer from which to create the stream object. </td></tr>
    <tr><td class="paramname">data_size</td><td>size of the buffer. </td></tr>
    <tr><td class="paramname">filter_chain</td><td>filter object with which to create the stream object. Defaults to Filters::Filter(0,false) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61c40391685d5c3f0581b6340edad42e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> pdftron::PDF::PDFDoc::CreateIndirectString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepdftron.html#a7bc90caf17b633a6832ec1e5162e1bc0">UChar</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method creates an SDF/Cos indirect string object</p>
<p>Unlike direct objects, indirect objects can be referenced by more than one object (i.e. indirect objects can be shared). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a new indirect string object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Unsigned char pointer with which to create the string object. </td></tr>
    <tr><td class="paramname">size</td><td>length of string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6c13eb519ae28730a641c07f9f98eb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> pdftron::PDF::PDFDoc::CreateIndirectString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method creates an SDF/Cos indirect string object</p>
<p>Unlike direct objects, indirect objects can be referenced by more than one object (i.e. indirect objects can be shared). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a new indirect string object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>reference to string with which to create the string object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5579459d83643e24ba7dcb9376248a9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a>* pdftron::PDF::PDFDoc::CreateInternal </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adaa6e0cfc68668edaffe0a177fce39fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_f_d_f_1_1_f_d_f_doc.html">FDF::FDFDoc</a> pdftron::PDF::PDFDoc::FDFExtract </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7967f365a4c14369836db9c3a43d4163">ExtractFlag</a>&#160;</td>
          <td class="paramname"><em>flag</em> = <code><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7967f365a4c14369836db9c3a43d4163ac76092a7e88aace0b2e947b27df9bc4a">e_forms_only</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract form data and/or annotations to <a class="el" href="namespacepdftron_1_1_f_d_f.html">FDF</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>- specifies extract options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly created <a class="el" href="namespacepdftron_1_1_f_d_f.html">FDF</a> file with an interactive data. </dd></dl>

</div>
</div>
<a class="anchor" id="acf1fb3485b40bcfa6388d0fb24b80ea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_f_d_f_1_1_f_d_f_doc.html">FDF::FDFDoc</a> pdftron::PDF::PDFDoc::FDFExtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_page_set.html">PageSet</a> &amp;&#160;</td>
          <td class="paramname"><em>pages_to_extract</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7967f365a4c14369836db9c3a43d4163">ExtractFlag</a>&#160;</td>
          <td class="paramname"><em>flag</em> = <code><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7967f365a4c14369836db9c3a43d4163ac76092a7e88aace0b2e947b27df9bc4a">e_forms_only</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract form data and/or annotations to <a class="el" href="namespacepdftron_1_1_f_d_f.html">FDF</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pages_to_extract</td><td>The set of pages for which to extract interactive data. </td></tr>
    <tr><td class="paramname">flag</td><td>specifies extract options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly created <a class="el" href="namespacepdftron_1_1_f_d_f.html">FDF</a> file with an interactive data. </dd></dl>

</div>
</div>
<a class="anchor" id="a1535535bc64f213394a5e7883f153a4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_f_d_f_1_1_f_d_f_doc.html">FDF::FDFDoc</a> pdftron::PDF::PDFDoc::FDFExtract </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classpdftron_1_1_p_d_f_1_1_annot.html">Annot</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>annotations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract selected annotations to <a class="el" href="namespacepdftron_1_1_f_d_f.html">FDF</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annotations</td><td>the annotation(s) to extract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly created <a class="el" href="namespacepdftron_1_1_f_d_f.html">FDF</a> file with the interactive data. </dd></dl>

</div>
</div>
<a class="anchor" id="accc8390ff326c4cf743bb4e0ff7c65c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_f_d_f_1_1_f_d_f_doc.html">FDF::FDFDoc</a> pdftron::PDF::PDFDoc::FDFExtract </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classpdftron_1_1_p_d_f_1_1_annot.html">Annot</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>annot_added</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classpdftron_1_1_p_d_f_1_1_annot.html">Annot</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>annot_modified</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classpdftron_1_1_p_d_f_1_1_annot.html">Annot</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>annot_deleted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract annotations to <a class="el" href="namespacepdftron_1_1_f_d_f.html">FDF</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annot_added</td><td>specifies the array of added annotations </td></tr>
    <tr><td class="paramname">annot_modified</td><td>specifies the array of modified annotations </td></tr>
    <tr><td class="paramname">annot_deleted</td><td>specifies the array of deleted annotations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly created <a class="el" href="namespacepdftron_1_1_f_d_f.html">FDF</a> file with an interactive data. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2fd9c9711fc5660acae0c5feba5ccf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::FDFMerge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_f_d_f_1_1_f_d_f_doc.html">FDF::FDFDoc</a> &amp;&#160;</td>
          <td class="paramname"><em>fdf_doc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Import form data from <a class="el" href="namespacepdftron_1_1_f_d_f.html">FDF</a> file to <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> interactive form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fdf_doc</td><td>a reference to the <a class="el" href="namespacepdftron_1_1_f_d_f.html">FDF</a> file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e5f655f8ab7f694c20b357503f8f17b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::FDFUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_f_d_f_1_1_f_d_f_doc.html">FDF::FDFDoc</a> &amp;&#160;</td>
          <td class="paramname"><em>fdf_doc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace existing form and annotation data with those imported from the <a class="el" href="namespacepdftron_1_1_f_d_f.html">FDF</a> file. It will make annotations in the <a class="el" href="namespacepdftron_1_1_f_d_f.html">FDF</a> match those in the <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a>. Since this method avoids updating annotations unnecessarily it works well with incremental save and can sometimes preserve annotation appearances, but it requires that the annotations intended to be in the final document be in the provided <a class="el" href="namespacepdftron_1_1_f_d_f.html">FDF</a> file. </p>
<dl class="section note"><dt>Note</dt><dd>Some <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> viewers (like Chrome) cannot display annotations that don't already have an appearance, so it is often desirable to call <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#af3f1847c93cb4847c5feb15636d4259f">PDFDoc.RefreshAnnotAppearances</a> after this method to ensure these annotations can still be displayed in those applications. </dd>
<dd>
This method is not suitable for realtime collaboration. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fdf_doc</td><td>a pointer to the <a class="el" href="namespacepdftron_1_1_f_d_f.html">FDF</a> file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afecbe75cf2739a18cac08090d8fe972b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html">Field</a> pdftron::PDF::PDFDoc::FieldCreate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html#ad5998483c479a65c6e022075f4adb2a3">Field::Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td>
          <td class="paramname"><em>field_value</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a>&#160;</td>
          <td class="paramname"><em>def_field_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new interactive form <a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html">Field</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>a string representing the fully qualified name of the field (e.g. "employee.name.first"). field_name must be either a unique name or equal to an existing terminal field name. </td></tr>
    <tr><td class="paramname">type</td><td>field type (e.g. <a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html#ad5998483c479a65c6e022075f4adb2a3a09f6d0ec7cc7267b75398abe87918b6b">Field::e_text</a>, <a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html#ad5998483c479a65c6e022075f4adb2a3af06734f437dcc371747e2edd8b746840">Field::e_button</a>, etc.) </td></tr>
    <tr><td class="paramname">field_value</td><td></td></tr>
    <tr><td class="paramname">def_field_value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new form <a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html">Field</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>'field_name' is equal to an existing non-terminal field name an exception is thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a804cf67bb184a5fc4d5a8ed96e99c094"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html">Field</a> pdftron::PDF::PDFDoc::FieldCreate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html#ad5998483c479a65c6e022075f4adb2a3">Field::Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>field_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>def_field_value</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new interactive form <a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html">Field</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>a string representing the fully qualified name of the field (e.g. "employee.name.first"). field_name must be either a unique name or equal to an existing terminal field name. </td></tr>
    <tr><td class="paramname">type</td><td>field type (e.g. <a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html#ad5998483c479a65c6e022075f4adb2a3a09f6d0ec7cc7267b75398abe87918b6b">Field::e_text</a>, <a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html#ad5998483c479a65c6e022075f4adb2a3af06734f437dcc371747e2edd8b746840">Field::e_button</a>, etc.) </td></tr>
    <tr><td class="paramname">field_value</td><td></td></tr>
    <tr><td class="paramname">def_field_value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new form <a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html">Field</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>'field_name' is equal to an existing non-terminal field name an exception is thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5ba369da0b667e703116d96b3ed06b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::FlattenAnnotations </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forms_only</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flatten all annotations in the document. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forms_only</td><td>if false flatten all annotations, otherwise flatten only form fields. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd2f659eff64463a0650d2cd188d65ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::GenerateThumbnails </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates thumbnail images for all the pages in this <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> document. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The maximum dimension (width or height) that thumbnails will have. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af924f9293105e3017f5e0b50122f1f5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> pdftron::PDF::PDFDoc::GetAcroForm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the AcroForm dictionary located in "/Root" or NULL if dictionary is not present. </dd></dl>

</div>
</div>
<a class="anchor" id="aa4fb360e6e72899f5ef0f6fb99fcf360"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepdftron_1_1_p_d_f.html#a98427c21d1e70ce06e74ecce1427b9fa">PDF::DigitalSignatureFieldIterator</a> pdftron::PDF::PDFDoc::GetDigitalSignatureFieldIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves an iterator that iterates over digital signature fields.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator that iterates over digital signature fields. </dd></dl>

</div>
</div>
<a class="anchor" id="a7bd0ba5c922d2d1788eec1091840d232"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_p_d_f_1_1_digital_signature_field.html#a4f38ee2e140cc95d81cc9faeff99e10f">PDF::DigitalSignatureField::DocumentPermissions</a> pdftron::PDF::PDFDoc::GetDigitalSignaturePermissions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the most restrictive document permissions locking level from all of the signed digital signatures in the document.</p>
<dl class="section return"><dt>Returns</dt><dd>An enumerated value representing the most restrictive document permission level found in the document. </dd></dl>

</div>
</div>
<a class="anchor" id="a42895db2ec142cf9d372c3418c6d2765"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc_info.html">PDFDocInfo</a> pdftron::PDF::PDFDoc::GetDocInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The class representing document information metadata. (i.e. entries in the document information dictionary). </dd></dl>

</div>
</div>
<a class="anchor" id="a5f7c876e5698d03a01f64ecd0104e3c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepdftron.html#a6106f9362df99a4041d3a446effd70fb">UInt64</a> pdftron::PDF::PDFDoc::GetDownloadedByteCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of bytes that have been downloaded, when <code><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7332c36cfb00e02ca4ef89bb70dc3eab">HasDownloader()</a></code> is True.</p>
<dl class="section return"><dt>Returns</dt><dd>The number bytes downloaded.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>'<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7332c36cfb00e02ca4ef89bb70dc3eab">HasDownloader()</a>` returns False, calling this method will result in an exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac69428d0409071aadd112c231b25eb3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html">Field</a> pdftron::PDF::PDFDoc::GetField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>- a string representing the fully qualified name of the field (e.g. "employee.name.first").</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a FieldIterator referring to an interactive <a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html">Field</a> or to invalid field if the field name was not found. If a given field name was not found itr.HasNext() will return false. For example:</dd></dl>
<div class="fragment"><div class="line">* <a class="code" href="namespacepdftron_1_1_p_d_f.html#af5da72315f20771f76f3a109ce43b941">FieldIterator</a> itr = pdfdoc.GetFieldIterator(<span class="stringliteral">&quot;name&quot;</span>);</div>
<div class="line">* <span class="keywordflow">if</span> (itr.HasNext()) {</div>
<div class="line">*   Console.WriteLine(<span class="stringliteral">&quot;Field name: {0}&quot;</span>, itr.Current().GetName());</div>
<div class="line">* }</div>
<div class="line">* <span class="keywordflow">else</span> { ...field was not found... }</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a345c0faef5043a1f9f249fc27c7711f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepdftron_1_1_p_d_f.html#af5da72315f20771f76f3a109ce43b941">FieldIterator</a> pdftron::PDF::PDFDoc::GetFieldIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An interactive form (sometimes referred to as an AcroForm) is a collection of fields for gathering information interactively from the user. A <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> document may contain any number of fields appearing on any combination of pages, all of which make up a single, global interactive form spanning the entire document.</p>
<p>The following methods are used to access and manipulate Interactive form fields (sometimes referred to as AcroForms).</p>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the first <a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html">Field</a> in the document.</dd></dl>
<p>The list of all Fields present in the document can be traversed as follows: </p>
<div class="fragment"><div class="line">* <a class="code" href="namespacepdftron_1_1_p_d_f.html#af5da72315f20771f76f3a109ce43b941">FieldIterator</a> itr = pdfdoc.GetFieldIterator();</div>
<div class="line">* <span class="keywordflow">for</span>(; itr.HasNext(); itr.Next()) {</div>
<div class="line">*   Field field = itr.Current();</div>
<div class="line">*   Console.WriteLine(<span class="stringliteral">&quot;Field name: {0}&quot;</span>, field.GetName());</div>
<div class="line">*  }</div>
<div class="line">* </div>
</div><!-- fragment --><p>For a sample, please refer to 'InteractiveForms' sample project. </p>

</div>
</div>
<a class="anchor" id="a8e8a89c45419c85d3cc08bc744d89db1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepdftron_1_1_p_d_f.html#af5da72315f20771f76f3a109ce43b941">FieldIterator</a> pdftron::PDF::PDFDoc::GetFieldIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An interactive form (sometimes referred to as an AcroForm) is a collection of fields for gathering information interactively from the user. A <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> document may contain any number of fields appearing on any combination of pages, all of which make up a single, global interactive form spanning the entire document.</p>
<p>The following methods are used to access and manipulate Interactive form fields (sometimes referred to as AcroForms).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>String representing the name of the field to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the <a class="el" href="classpdftron_1_1_p_d_f_1_1_field.html">Field</a> in the document.</dd></dl>
<p>For a sample, please refer to 'InteractiveForms' sample project. </p>

</div>
</div>
<a class="anchor" id="ae93bd0070c427c27682de25b4fa34bdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_u_string.html">UString</a> pdftron::PDF::PDFDoc::GetFileName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The filename of the document if the document is loaded from disk, or empty string if the document is not yet saved or is loaded from a memory buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a90a55bd563a548b478492610b080ad10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="classpdftron_1_1_p_d_f_1_1_bookmark.html">Bookmark</a> pdftron::PDF::PDFDoc::GetFirstBookmark </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>- the first <a class="el" href="classpdftron_1_1_p_d_f_1_1_bookmark.html">Bookmark</a> from the document's outline tree. If the <a class="el" href="classpdftron_1_1_p_d_f_1_1_bookmark.html">Bookmark</a> tree is empty the underlying SDF/Cos Object is null and returned <a class="el" href="classpdftron_1_1_p_d_f_1_1_bookmark.html">Bookmark</a> is not valid (i.e. <a class="el" href="classpdftron_1_1_p_d_f_1_1_bookmark.html#a646cd393951df366db00fe5f4595eb1a">Bookmark::IsValid()</a> returns false). </dd></dl>

</div>
</div>
<a class="anchor" id="a5bdee56173d66893c7cf3db144c3e0f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t pdftron::PDF::PDFDoc::GetHandleInternal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9dad92927363622267398b640219aafb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_p_d_f_1_1_o_c_g_1_1_config.html">OCG::Config</a> pdftron::PDF::PDFDoc::GetOCGConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the default optional-content configuration for the document from the OCProperties D entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a716ea1550ffd6c6de6fc26c0ed019c2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> pdftron::PDF::PDFDoc::GetOCGs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the Obj array that contains optional-content groups (OCGs) for the document, or NULL if the document does not contain any OCGs. The order of the groups is not guaranteed to be the creation order, and is not the same as the display order. </dd></dl>

</div>
</div>
<a class="anchor" id="ab3416f3730763a856346092edb8a80cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_p_d_f_1_1_action.html">Action</a> pdftron::PDF::PDFDoc::GetOpenAction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpdftron_1_1_p_d_f_1_1_action.html">Action</a> that is triggered when the document is opened. The returned action can be either a destination or some other kind of <a class="el" href="classpdftron_1_1_p_d_f_1_1_action.html">Action</a> (see Section 8.5, 'Actions' in <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> Reference Manual).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>if the document does not nave associated action the returned <a class="el" href="classpdftron_1_1_p_d_f_1_1_action.html">Action</a> will be null (i.e. <a class="el" href="classpdftron_1_1_p_d_f_1_1_action.html#ac8b06b277005867bac9c76c41d2d3983">Action.IsValid()</a> returns false) </dd></dl>

</div>
</div>
<a class="anchor" id="a5c631eb201267494ce3e7c0025af1f79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a> pdftron::PDF::PDFDoc::GetPage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a>&#160;</td>
          <td class="paramname"><em>page_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_number</td><td>- the page number in document's page sequence. <a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a> numbers in document's page sequence are indexed from 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a> corresponding to a given page number, or null (invalid page) if the document does not contain the given page number.</dd></dl>
<p>For example: </p>
<div class="fragment"><div class="line">*   Page page = pdfdoc.GetPage(page_num);</div>
<div class="line">*   <span class="keywordflow">if</span> (page == null) <span class="keywordflow">return</span>; <span class="comment">//  Page not found</span></div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a03d0cd1a5e1dcb68ff92552b5ae621be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pdftron::PDF::PDFDoc::GetPageCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of pages in the document. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d15cf0c0510932ba886740f64952c91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepdftron_1_1_p_d_f.html#a5b4283a73763ea46351409cc9598ea66">PageIterator</a> pdftron::PDF::PDFDoc::GetPageIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a>&#160;</td>
          <td class="paramname"><em>page_number</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the Next() method on the returned iterator to traverse all pages in the document. For example: </p>
<div class="fragment"><div class="line">*   <a class="code" href="namespacepdftron_1_1_p_d_f.html#a5b4283a73763ea46351409cc9598ea66">PageIterator</a> itr = pdfdoc.GetPageIterator();</div>
<div class="line">*   <span class="keywordflow">while</span> (itr.HasNext()) { <span class="comment">//  Read every page</span></div>
<div class="line">*      Page page = itr.Current();</div>
<div class="line">*      <span class="comment">// ...</span></div>
<div class="line">*      itr.Next()</div>
<div class="line">*   }</div>
<div class="line">* </div>
</div><!-- fragment --><p>For full sample code, please take a look at <a class="el" href="classpdftron_1_1_p_d_f_1_1_element_reader.html">ElementReader</a>, PDFPageTest and <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_draw.html">PDFDraw</a> sample projects. </p>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the first page in the document. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_number</td><td>page to set the iterator on. 1 corresponds to the first page. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4720ab712a9049f845f0947ac495302e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_p_d_f_1_1_page_label.html">PageLabel</a> pdftron::PDF::PDFDoc::GetPageLabel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>page_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classpdftron_1_1_p_d_f_1_1_page_label.html">PageLabel</a> that is in effect for the given page. If there is no label object in effect, this method returns an invalid page label object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_num</td><td>The page number. Because <a class="el" href="classpdftron_1_1_p_d_f_net.html">PDFNet</a> indexes pages starting from 1, page_num must be larger than 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0fffdd194185d2253a063e5fe457c29f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> pdftron::PDF::PDFDoc::GetPages </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>- A dictionary representing the root of the low level page-tree </dd></dl>

</div>
</div>
<a class="anchor" id="ae644be52ed8fdd52711c6186a7f644dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> pdftron::PDF::PDFDoc::GetRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>- A dictionary representing the Cos root of the document (/Root entry within the trailer dictionary) </dd></dl>

</div>
</div>
<a class="anchor" id="af119c1bd1c5c9e9185c6c2a1a97329a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDF::SDFDoc</a>&amp; pdftron::PDF::PDFDoc::GetSDFDoc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>document's SDF/Cos document </dd></dl>

</div>
</div>
<a class="anchor" id="af8ae14bfbc42ce8efaca89cd5095e706"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_security_handler.html">SDF::SecurityHandler</a> pdftron::PDF::PDFDoc::GetSecurityHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Currently selected SecurityHandler.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#adc0d28e22efa7856249874012a81d4fe">InitSecurityHandler()</a> should be called before <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#af8ae14bfbc42ce8efaca89cd5095e706">GetSecurityHandler()</a> in order to initialize the handler.</dd>
<dd>
Returned security handler can be modified in order to change the security settings of the existing document. Changes to the current handler will not invalidate the access to the original file and will take effect during document <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ad486c18e60424b253164bfaa481a759b">Save()</a>.</dd>
<dd>
If the security handler is modified, document will perform a full save even if e_incremental was given as a flag in <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ad486c18e60424b253164bfaa481a759b">Save()</a> method. </dd></dl>

</div>
</div>
<a class="anchor" id="a254315cd040e3d927faa00f8591a276d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_signature_handler.html">SDF::SignatureHandler</a>* pdftron::PDF::PDFDoc::GetSignatureHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepdftron_1_1_s_d_f.html#a38b73540250fd07f741bbe4fba66634a">SDF::SignatureHandlerId</a>&#160;</td>
          <td class="paramname"><em>signature_handler_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the associated signature handler instance from the signature manager by looking it up with the handler name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signature_handler_id</td><td>The unique id of the signature handler to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signature handler instance if found, otherwise NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a874cc47e1b0b28378ab63eeae30e1266"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_p_d_f_1_1_struct_1_1_s_tree.html">Struct::STree</a> pdftron::PDF::PDFDoc::GetStructTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The document's logical structure tree root. </dd></dl>

</div>
</div>
<a class="anchor" id="afcafeea21843f9cc6d96522eba503090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepdftron.html#a6106f9362df99a4041d3a446effd70fb">UInt64</a> pdftron::PDF::PDFDoc::GetTotalRemoteByteCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the document's total size in bytes, when <code><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7332c36cfb00e02ca4ef89bb70dc3eab">HasDownloader()</a></code> is True.</p>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes in the remote document.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>'<a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a7332c36cfb00e02ca4ef89bb70dc3eab">HasDownloader()</a>` returns False, calling this method will result in an exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a32e8ceb8178e032c2ae1c6a80453d3c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> pdftron::PDF::PDFDoc::GetTrailer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>- A dictionary representing the Cos root of the document (document's trailer) </dd></dl>

</div>
</div>
<a class="anchor" id="a5ab2dc9379e183dc58cc6f6ab638b7c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_obj.html">SDF::Obj</a> pdftron::PDF::PDFDoc::GetTriggerAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a17d1f00bcaf9272f316b2bd0adc28cb5">PDFDoc::ActionTriggerEvent</a>&#160;</td>
          <td class="paramname"><em>trigger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the <a class="el" href="classpdftron_1_1_p_d_f_1_1_action.html">Action</a> associated with the selected Doc Trigger event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trigger</td><td>the type of trigger event to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classpdftron_1_1_p_d_f_1_1_action.html">Action</a> Obj if present, otherwise NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ac02f45cdc6a9114a42c89ea915c7529d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_s_d_f_1_1_undo_manager.html">SDF::UndoManager</a> pdftron::PDF::PDFDoc::GetUndoManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The UndoManager object (one-to-one mapped to document) </dd></dl>

</div>
</div>
<a class="anchor" id="a627467adeb4d6bcc6488cdaae2b56e1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc_view_prefs.html">PDFDocViewPrefs</a> pdftron::PDF::PDFDoc::GetViewPrefs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Viewer preferences for this document.</dd></dl>
<p><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc_view_prefs.html">PDFDocViewPrefs</a> is a high-level utility class that can be used to control the way the document is to be presented on the screen or in print. </p>

</div>
</div>
<a class="anchor" id="a7332c36cfb00e02ca4ef89bb70dc3eab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::PDF::PDFDoc::HasDownloader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether this document was created via the <code><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_view_ctrl.html">PDFViewCtrl</a></code> method <code>OpenURLAsync</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the document was created via the <code><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_view_ctrl.html">PDFViewCtrl</a></code> method <code>OpenURLAsync</code>; False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2a8ee81c1a018b7730f47d6d1e5c9df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::PDF::PDFDoc::HasOC </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the optional content (OC) feature is associated with the document. The document is considered to have optional content if there is an OCProperties dictionary in the document's catalog, and that dictionary has one or more entries in the OCGs array. </dd></dl>

</div>
</div>
<a class="anchor" id="aabc52e937bd061e822691a165b26c7f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::PDF::PDFDoc::HasRepairedXRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether or not the underlying file has an XRef table that had to be repaired when the file was opened. If the document had an invalid XRef table when opened, <a class="el" href="classpdftron_1_1_p_d_f_net.html">PDFNet</a> will have repaired the XRef table for its working representation of the document.</p>
<dl class="section return"><dt>Returns</dt><dd>- true if document was found to be corrupted, and was repaired, during opening and has not been saved since.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>- If this function returns true, it is not possible to incrementally save the document (see <a href="http://www.pdftron.com/kb_corrupt_xref">http://www.pdftron.com/kb_corrupt_xref</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="a46a871d707a670880eff9cea9f943318"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::PDF::PDFDoc::HasSignatures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether this documents contains any digital signatures. </p>
<dl class="section return"><dt>Returns</dt><dd>True if a digital signature is found in this <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a160351aee694729669b0514b75ef4251"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pdftron::PDF::PDFDoc::HighlightTextDiff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;&#160;</td>
          <td class="paramname"><em>doc1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;&#160;</td>
          <td class="paramname"><em>doc2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_text_diff_options.html">TextDiffOptions</a> *&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Imports two external PDFs and highlights the differences between them. This function directly adds the highlights to the two input documents. Note: Each contiguous block of change is considered a single difference. A deletion immediately followed by an insertion is considered a single edit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doc1</td><td>is the before document, the basis of the comparison </td></tr>
    <tr><td class="paramname">doc2</td><td>is the after document, to which the basis is compared </td></tr>
    <tr><td class="paramname">options</td><td>processing options (optional) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of differences found </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is beta and is subject to change </dd></dl>

</div>
</div>
<a class="anchor" id="ad230a2a036e1b8e999a7c1aafe145619"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a>&gt; pdftron::PDF::PDFDoc::ImportPages </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>import_bookmarks</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function imports a list of pages to this document. Although a list of pages can be imported using repeated calls to <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#abebadf120389e86cfc8d532eda9dbd82">PageInsert()</a>, PageImport will not import duplicate copies of resources that are shared across pages (such as fonts, images, colorspaces etc). Therefore this method is recommended when a page import list consists of several pages that share the same resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pages</td><td>A list of pages to import. All pages should belong to the same source document. </td></tr>
    <tr><td class="paramname">import_bookmarks</td><td>An optional flag specifying whether any bookmark items pointing to pages in the import list should be merged with the target (i.e. this) document.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of imported pages. Note that imported pages are not placed in the document page sequence. This can be done using methods such as <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#abebadf120389e86cfc8d532eda9dbd82">PageInsert()</a>, <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a20b4e09872be651fe31145310281fa34">PagePushBack()</a>, etc. </dd></dl>

</div>
</div>
<a class="anchor" id="adc0d28e22efa7856249874012a81d4fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::PDF::PDFDoc::InitSecurityHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>custom_data</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes document's SecurityHandler. This version of <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#adc0d28e22efa7856249874012a81d4fe">InitSecurityHandler()</a> works with Standard and Custom <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> security and can be used in situations where the password is obtained dynamically via user feedback. See EncTest sample for example code.</p>
<p>This function should be called immediately after an encrypted document is opened. The function does not have any side effects on documents that are not encrypted.</p>
<p>If the security handler was successfully initialized it can be later obtained using <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#af8ae14bfbc42ce8efaca89cd5095e706">GetSecurityHandler()</a> method.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">An</td><td>exception is thrown if the matching handler for document's security was not found in the global SecurityManager. In this case, you need to register additional custom security handlers with the global SecurityManager (using SecurityManagerSingleton).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the SecurityHandler was successfully initialized (this may include authentication data collection, verification etc.), false otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">custom_data</td><td>An optional parameter used to specify custom data that should be passed in SecurityHandler::Initialize() callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf066e5ddfd8311e2257702e2c05e0b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::PDF::PDFDoc::InitStdSecurityHandler </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>password_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes document's SecurityHandler using the supplied password. This version of <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#adc0d28e22efa7856249874012a81d4fe">InitSecurityHandler()</a> assumes that document uses Standard security and that a password is specified directly.</p>
<p>This function should be called immediately after an encrypted document is opened. The function does not have any side effects on documents that are not encrypted.</p>
<p>If the security handler was successfully initialized, it can be later obtained using <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#af8ae14bfbc42ce8efaca89cd5095e706">GetSecurityHandler()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the given password successfully unlocked the document, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">An</td><td>exception is thrown if the document's security Filter is not 'Standard'. In this case, you need to register additional custom security handlers with the global SecurityManager (SecurityManagerSingleton).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>Specifies the password used to open the document without any user feedback. If you would like to dynamically obtain the password, you need to derive a custom class from StdSecurityHandler() and use <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#adc0d28e22efa7856249874012a81d4fe">InitSecurityHandler()</a> without any parameters. See EncTest sample for example code.</td></tr>
    <tr><td class="paramname">password_sz</td><td>An optional parameter used to specify the size of the password buffer, in bytes. If the 'password_sz' is 0, or if the parameter is not specified, the function assumes that the string is null terminated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Deprecated. Use versions that accepts <a class="el" href="classpdftron_1_1_u_string.html">UString</a> or buffer instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b5fa9c6a75b23a8b070960a8f0d3e55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::PDF::PDFDoc::InitStdSecurityHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">pdftron::UString</a> &amp;&#160;</td>
          <td class="paramname"><em>password</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes document's SecurityHandler using the supplied password. This version of <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#adc0d28e22efa7856249874012a81d4fe">InitSecurityHandler()</a> assumes that document uses Standard security and that a password is specified directly.</p>
<p>This function should be called immediately after an encrypted document is opened. The function does not have any side effects on documents that are not encrypted.</p>
<p>If the security handler was successfully initialized, it can be later obtained using <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#af8ae14bfbc42ce8efaca89cd5095e706">GetSecurityHandler()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>Specifies the password used to open the document without any user feedback. If you would like to dynamically obtain the password, you need to derive a custom class from StdSecurityHandler() and use <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#adc0d28e22efa7856249874012a81d4fe">InitSecurityHandler()</a> without any parameters. See EncTest sample for example code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the given password successfully unlocked the document, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">An</td><td>exception is thrown if the document's security Filter is not 'Standard'. In this case, you need to register additional custom security handlers with the global SecurityManager (SecurityManagerSingleton). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9892fd705ebbe4910513f23116b469ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::PDF::PDFDoc::InitStdSecurityHandler </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacepdftron.html#a2538e0861ab3366a3bfab3665d0cd137">UInt8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>password_buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes document's SecurityHandler using the supplied password. This version of <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#adc0d28e22efa7856249874012a81d4fe">InitSecurityHandler()</a> assumes that document uses Standard security and that a password is specified directly.</p>
<p>This function should be called immediately after an encrypted document is opened. The function does not have any side effects on documents that are not encrypted.</p>
<p>If the security handler was successfully initialized, it can be later obtained using <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#af8ae14bfbc42ce8efaca89cd5095e706">GetSecurityHandler()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password_buf</td><td>Specifies the password used to open the document without any user feedback. If you would like to dynamically obtain the password, you need to derive a custom class from StdSecurityHandler() and use <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#adc0d28e22efa7856249874012a81d4fe">InitSecurityHandler()</a> without any parameters. See EncTest sample for example code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the given password successfully unlocked the document, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">An</td><td>exception is thrown if the document's security Filter is not 'Standard'. In this case, you need to register additional custom security handlers with the global SecurityManager (SecurityManagerSingleton). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91a75ca0e86e9fb587317e0d730c3b48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::InsertPages </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>insert_before_page_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;&#160;</td>
          <td class="paramname"><em>src_doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ac43e9216b77ce9c7f52290f17bdbfc4d">InsertFlag</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Common::ProgressMonitor *&#160;</td>
          <td class="paramname"><em>monitor</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a range of pages from specified <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insert_before_page_number</td><td>- the destination of the insertion. If less than or equal to 1, the pages are added to the beginning of the document. If larger than the number of pages in the destination document, the pages are appended to the document. </td></tr>
    <tr><td class="paramname">src_doc</td><td>- source <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> to insert from </td></tr>
    <tr><td class="paramname">start_page</td><td>- start of the page number to insert </td></tr>
    <tr><td class="paramname">end_page</td><td>- end of the page number to insert </td></tr>
    <tr><td class="paramname">flag</td><td>- specifies insert options </td></tr>
    <tr><td class="paramname">progress</td><td>- A pointer to the progress interface. NULL if progress tracking is not required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a565081b08450cb8d7e909a21cbe1fbb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::InsertPages </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>insert_before_page_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;&#160;</td>
          <td class="paramname"><em>src_doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_p_d_f_1_1_page_set.html">PageSet</a> &amp;&#160;</td>
          <td class="paramname"><em>source_page_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ac43e9216b77ce9c7f52290f17bdbfc4d">InsertFlag</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Common::ProgressMonitor *&#160;</td>
          <td class="paramname"><em>monitor</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a range of pages from specified <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> using <a class="el" href="classpdftron_1_1_p_d_f_1_1_page_set.html">PageSet</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insert_before_page_number</td><td>- the destination of the insertion. If less than or equal to 1, the pages are added to the beginning of the document. If larger than the number of pages in the destination document, the pages are appended to the document. </td></tr>
    <tr><td class="paramname">src_doc</td><td>- source <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> to insert from </td></tr>
    <tr><td class="paramname">source_page_set</td><td>- a collection of the page number to insert </td></tr>
    <tr><td class="paramname">flag</td><td>- specifies insert options </td></tr>
    <tr><td class="paramname">progress</td><td>- A pointer to the progress interface. NULL if progress tracking is not required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9410730cef91472ecf9a472c772e83d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::PDF::PDFDoc::IsEncrypted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the document is/was originally encrypted false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8ab756dbd661949ea74b204616c232d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::PDF::PDFDoc::IsLinearized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call this function to determine whether the document is represented in linearized (fast web view) format.</p>
<dl class="section return"><dt>Returns</dt><dd>- true if document is stored in fast web view format, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>any changes to the document can invalidate linearization. The function will return 'true' only if the original document is linearized and if it is not modified.</dd></dl>
<p>In order to provide good performance over relatively slow communication links, <a class="el" href="classpdftron_1_1_p_d_f_net.html">PDFNet</a> can generate <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> documents with linearized objects and hint tables that can allow a <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> viewer application to download and view one page of a <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> file at a time, rather than requiring the entire file (including fonts and images) to be downloaded before any of it can be viewed.</p>
<p>To save a document in linearized (fast web view) format you only need to pass 'Doc.SaveOptions.e_linearized' flag in the Save method. </p>

</div>
</div>
<a class="anchor" id="a563c1ffb754d2fb10ed9bec3583e19d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::PDF::PDFDoc::IsModified </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call this function to determine whether the document has been modified since it was last saved.</p>
<dl class="section return"><dt>Returns</dt><dd>- true if document was modified, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ac1cbff86d5df038add391c09a978a39e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::PDF::PDFDoc::IsTagged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this document is marked as Tagged <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a>, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e4d84e5af00585b8b4763fc06c95a95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::Lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locks the document to prevent competing threads from accessing the document at the same time. Threads attempting to access the document will wait in suspended state until the thread that owns the lock calls doc.Unlock(). </p>

</div>
</div>
<a class="anchor" id="a7379968d42005593f9de5d4bf695cdd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::LockRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locks the document to prevent competing write threads (using <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#a5e4d84e5af00585b8b4763fc06c95a95">Lock()</a>) from accessing the document at the same time. Other reader threads however, will be allowed to access the document. Threads attempting to obtain write access to the document will wait in suspended state until the thread that owns the lock calls doc.UnlockRead(). Note: To avoid deadlocks obtaining a write lock while holding a read lock is not permitted and will throw an exception. If this situation is encountered please either unlock the read lock before the write lock is obtained or acquire a write lock (rather than read lock) in the first place. </p>

</div>
</div>
<a class="anchor" id="a91dd9750f64f1962f1e288b7719c296d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::MergeXFDF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a>&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_p_d_f_1_1_merge_x_f_d_f_options.html">MergeXFDFOptions</a> *&#160;</td>
          <td class="paramname"><em>opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge existing form and annotation data with those imported from the XFDF file. It will replace annotations from pdfdocument with matching annotations from XFDF. In order for the annotations to be considered matching, "name" of the xfdf annotation needs to match "NM" of that in pdf. XFDF annotations that don't have a match in the pdf document will be added. For regular xfdf files, no deletions will be made This method also supports command form of xfdf, for those files, deletions will be performed for annotations in "delete" section Since this method avoids updating annotations unnecessarily it works well with incremental save. Note: This method is suitable for realtime collaboration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><ul>
<li>Input Filter which provides the xfdf contents </li>
</ul>
</td></tr>
    <tr><td class="paramname">opts</td><td><ul>
<li><a class="el" href="classpdftron_1_1_p_d_f_1_1_merge_x_f_d_f_options.html">MergeXFDFOptions</a> object for finer control </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">PDFNetException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae18e13f3299e4b32dcbc868e62b4be76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::MergeXFDF </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>xfdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_p_d_f_1_1_merge_x_f_d_f_options.html">MergeXFDFOptions</a> *&#160;</td>
          <td class="paramname"><em>opts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge existing form and annotation data with those imported from the XFDF file. It will replace annotations from pdfdocument with matching annotations from XFDF. In order for the annotations to be considered matching, "name" of the xfdf annotation needs to match "NM" of that in pdf. XFDF annotations that don't have a match in the pdf document will be added. For regular xfdf files, no deletions will be made This method also supports command form of xfdf, for those files, deletions will be performed for annotations in "delete" section Since this method avoids updating annotations unnecessarily it works well with incremental save. Note: This method is suitable for realtime collaboration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xfdf</td><td><ul>
<li>xfdf contents in string form or the path to the xfdf file </li>
</ul>
</td></tr>
    <tr><td class="paramname">opts</td><td><ul>
<li><a class="el" href="classpdftron_1_1_p_d_f_1_1_merge_x_f_d_f_options.html">MergeXFDFOptions</a> object for finer control </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">PDFNetException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3f7d552487d82607564fa4095ed07da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::MovePages </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>move_before_page_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;&#160;</td>
          <td class="paramname"><em>src_doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ac43e9216b77ce9c7f52290f17bdbfc4d">InsertFlag</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Common::ProgressMonitor *&#160;</td>
          <td class="paramname"><em>monitor</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves a range of pages from specified <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a>. Pages are deleted from source document after move.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">move_before_page_number</td><td>- the destination of the move. If less than or equal to 1, the pages are moved to the beginning of the document. If larger than the number of pages in the destination document, the pages are moved to the end of the document. </td></tr>
    <tr><td class="paramname">src_doc</td><td>- source <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> to move from </td></tr>
    <tr><td class="paramname">start_page</td><td>- start of the page number to move </td></tr>
    <tr><td class="paramname">end_page</td><td>- end of the page number to move </td></tr>
    <tr><td class="paramname">flag</td><td>- specifies insert options </td></tr>
    <tr><td class="paramname">progress</td><td>- A pointer to the progress interface. NULL if progress tracking is not required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>MovePages function does not save src_doc. It merely delete pages in memeory. For permanent changes, <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ad486c18e60424b253164bfaa481a759b">PDFDoc::Save</a> should be used to save src_doc after function exists. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f57a974567e5e2d9d386540f397622e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::MovePages </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>move_before_page_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;&#160;</td>
          <td class="paramname"><em>src_doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_p_d_f_1_1_page_set.html">PageSet</a> &amp;&#160;</td>
          <td class="paramname"><em>source_page_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ac43e9216b77ce9c7f52290f17bdbfc4d">InsertFlag</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Common::ProgressMonitor *&#160;</td>
          <td class="paramname"><em>monitor</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves a range of pages from specified <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a>. Pages are deleted from source document after move.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">move_before_page_number</td><td>- the destination of the move. If less than or equal to 1, the pages are moved to the beginning of the document. If larger than the number of pages in the destination document, the pages are moved to the end of the document. </td></tr>
    <tr><td class="paramname">src_doc</td><td>- source <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> to move from </td></tr>
    <tr><td class="paramname">source_page_set</td><td>- a collection of the page number to move </td></tr>
    <tr><td class="paramname">flag</td><td>- specifies insert options </td></tr>
    <tr><td class="paramname">progress</td><td>- A pointer to the progress interface. NULL if progress tracking is not required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>MovePages function does not save src_doc. It merely delete pages in memeory. For permanent changes, <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ad486c18e60424b253164bfaa481a759b">PDFDoc::Save</a> should be used to save src_doc after function exists. </dd></dl>

</div>
</div>
<a class="anchor" id="af3167b167a9cdd5d5454b6216847196c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pdftron::PDF::PDFDoc::operator <a class="el" href="classpdftron_1_1_s_d_f_1_1_s_d_f_doc.html">SDF::SDFDoc</a> &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Explicit conversion operator from <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> to SDF::Doc. </p>
<dl class="section return"><dt>Returns</dt><dd>document's SDF/Cos document </dd></dl>

<p>Definition at line <a class="el" href="_p_d_f_doc_8h_source.html#l01383">1383</a> of file <a class="el" href="_p_d_f_doc_8h_source.html">PDFDoc.h</a>.</p>

</div>
</div>
<a class="anchor" id="a83504d30edb68eaacd6417458af2f5a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a>&amp; pdftron::PDF::PDFDoc::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a07c8ed034327fc5e151bf626126e3623"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a> pdftron::PDF::PDFDoc::PageCreate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_p_d_f_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>media_box</em> = <code><a class="el" href="classpdftron_1_1_p_d_f_1_1_rect.html">Rect</a>(0,&#160;0,&#160;612,&#160;792)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new, empty page in the document. You can use PageWriter to fill the page with new content. Finally the page should be inserted at specific place within document page sequence using PageInsert/PagePushFront/PagePushBack methods.</p>
<dl class="section return"><dt>Returns</dt><dd>A new, empty page.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>the new page still does not belong to document page sequence and should be subsequently placed at a specific location within the sequence.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">media_box</td><td>A rectangle, expressed in default user space units, defining the boundaries of the physical medium on which the page is intended to be displayed or printed. A user space units is 1/72 of an inch. If media_box is not specified the default dimensions of the page are 8.5 x 11 inches (or 8.5*72, 11*72 units).</td></tr>
  </table>
  </dd>
</dl>
<p>The following is a listing of some standard U.S. page sizes:</p>
<ul>
<li>
Letter = Rect(0, 0, 612, 792) </li>
<li>
Legal = Rect(0, 0, 612, 1008) </li>
<li>
Ledger = Rect(0, 0, 1224, 792) </li>
<li>
Tabloid = Rect(0, 0, 792, 1224) </li>
<li>
Executive = Rect(0, 0, 522, 756) </li>
</ul>
<p>The following is a listing of ISO standard page sizes:</p>
<ul>
<li>
4A0 = Rect(0, 0, 4768, 6741) </li>
<li>
2A0 = Rect(0, 0, 3370, 4768) </li>
<li>
A0 = Rect(0, 0, 2384, 3370) </li>
<li>
A1 = Rect(0, 0, 1684, 2384) </li>
<li>
A2 = Rect(0, 0, 1191, 1684) </li>
<li>
A3 = Rect(0, 0, 842,  1191) </li>
<li>
A4 = Rect(0, 0, 595,  842) </li>
<li>
A5 = Rect(0, 0, 420,  595) </li>
<li>
A6 = Rect(0, 0, 298,  420) </li>
<li>
A7 = Rect(0, 0, 210,  298) </li>
<li>
A8 = Rect(0, 0, 147,  210) </li>
<li>
A9 = Rect(0, 0, 105,  147) </li>
<li>
A10 = Rect(0, 0, 74,   105) </li>
<li>
B0 = Rect(0, 0, 2835, 4008) </li>
<li>
B1 = Rect(0, 0, 2004, 2835) </li>
<li>
B2 = Rect(0, 0, 1417, 2004) </li>
<li>
B3 = Rect(0, 0, 1001, 1417) </li>
<li>
B4 = Rect(0, 0, 709,  1001) </li>
<li>
B5 = Rect(0, 0, 499,  709) </li>
<li>
B6 = Rect(0, 0, 354,  499) </li>
<li>
B7 = Rect(0, 0, 249,  354) </li>
<li>
B8 = Rect(0, 0, 176,  249) </li>
<li>
B9 = Rect(0, 0, 125,  176) </li>
<li>
B10 = Rect(0, 0, 88,   125) </li>
<li>
C0 = Rect(0, 0, 2599, 3677) </li>
<li>
C1 = Rect(0, 0, 1837, 2599) </li>
<li>
C2 = Rect(0, 0, 1298, 1837) </li>
<li>
C3 = Rect(0, 0, 918,  1298) </li>
<li>
C4 = Rect(0, 0, 649,  918) </li>
<li>
C5 = Rect(0, 0, 459,  649) </li>
<li>
C6 = Rect(0, 0, 323,  459) </li>
<li>
C7 = Rect(0, 0, 230,  323) </li>
<li>
C8 = Rect(0, 0, 162,  230) </li>
<li>
C9 = Rect(0, 0, 113,  162) </li>
<li>
C10 = Rect(0, 0, 79,   113) </li>
</ul>

</div>
</div>
<a class="anchor" id="abebadf120389e86cfc8d532eda9dbd82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::PageInsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepdftron_1_1_p_d_f.html#a5b4283a73763ea46351409cc9598ea66">PageIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a>&#160;</td>
          <td class="paramname"><em>page</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert/Import a single page at a specific location in the page sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">where</td><td>- The location in the page sequence indicating where to insert the page. The page is inserted before the specified location.</td></tr>
    <tr><td class="paramname">page</td><td>- A page to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Invalidates all PageIterators pointing to the document. </dd></dl>

</div>
</div>
<a class="anchor" id="a20b4e09872be651fe31145310281fa34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::PagePushBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a>&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a page to the end of a document's page sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>- a page to append to the document </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Invalidates all PageIterators pointing to the document. </dd></dl>

</div>
</div>
<a class="anchor" id="ad363a33ee80b44997f6aaed503041976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::PagePushFront </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_page.html">Page</a>&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a page to the beginning of a document's page sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>- a page to prepend to the document Invalidates all PageIterators pointing to the document. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedf8589d289d3fbae8a7f4139d48722e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::PageRemove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepdftron_1_1_p_d_f.html#a5b4283a73763ea46351409cc9598ea66">PageIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>page_itr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_itr</td><td>- the PageIterator to the page that should be removed A PageIterator for the given page can be obtained using PDFDoc::GetPageIterator(page_num) or using direct iteration through document's page sequence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3f1847c93cb4847c5feb15636d4259f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::RefreshAnnotAppearances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_p_d_f_1_1_refresh_options.html">RefreshOptions</a> *&#160;</td>
          <td class="paramname"><em>options</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates the appearance stream for annotations in the document using the specified options. A common use case is to generate appearances only for missing annotations, which can be accomplished using the default options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Options that can be used to adjust this generation process. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a497139a384bd6fcb864f11e39b3f22db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::RefreshFieldAppearances </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Regenerates the appearance stream for every widget annotation in the document Call this method if you modified field's value and would like to update field's appearances. </p>

</div>
</div>
<a class="anchor" id="a0e1d9d6ca294791c44e2f4527ab138bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::RemovePageLabel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>page_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the page label that is attached to the specified page, effectively merging the specified range with the previous page label sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_num</td><td>The page from which the page label is removed. Because <a class="el" href="classpdftron_1_1_p_d_f_net.html">PDFNet</a> indexes pages starting from 1, page_num must be larger than 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae5303073494e2f3d87e7d49388722e73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::RemoveSecurity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function removes document security. </p>

</div>
</div>
<a class="anchor" id="a85a87c60bcfad1e97112006017241d3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::RemoveSignatureHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepdftron_1_1_s_d_f.html#a38b73540250fd07f741bbe4fba66634a">SDF::SignatureHandlerId</a>&#160;</td>
          <td class="paramname"><em>signature_handler_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a signature handler from the signature manager.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signature_handler_id</td><td>The unique id of the signature handler to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad486c18e60424b253164bfaa481a759b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::Save </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the document to a file.</p>
<p>If a full save is requested to the original path, the file is saved to a file system-determined temporary file, the old file is deleted, and the temporary file is renamed to path.</p>
<p>A full save with remove unused or linearization option may re-arrange object in the cross reference table. Therefore all pointers and references to document objects and resources should be re acquired in order to continue document editing.</p>
<p>In order to use incremental save the specified path must match original path and e_incremental flag bit should be set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>- The full path name to which the file is saved. </td></tr>
    <tr><td class="paramname">flags</td><td>- A bit field composed of an OR of SDFDoc::SaveOptions values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">-</td><td>if the file can't be opened for saving or if there is a problem during Save an Exception object will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>- Save will modify the <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> object's internal representation. As such, the user should acquire a write lock before calling save.</dd>
<dd>
- If the original pdf has a corrupt xref table (see HasRepairedXref), then it can not be saved using the e_incremental flag. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f74bf3a5a4b8243f96083134eaa3100"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::Save </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Common::ProgressMonitor *&#160;</td>
          <td class="paramname"><em>progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the document to a file.</p>
<p>If a full save is requested to the original path, the file is saved to a file system-determined temporary file, the old file is deleted, and the temporary file is renamed to path.</p>
<p>A full save with remove unused or linearization option may re-arrange object in the cross reference table. Therefore all pointers and references to document objects and resources should be re acquired in order to continue document editing.</p>
<p>In order to use incremental save the specified path must match original path and e_incremental flag bit should be set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>- The full path name to which the file is saved. </td></tr>
    <tr><td class="paramname">flags</td><td>- A bit field composed of an OR of SDFDoc::SaveOptions values. </td></tr>
    <tr><td class="paramname">progress</td><td>- A pointer to the progress interface. NULL if progress tracking is not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">-</td><td>if the file can't be opened for saving or if there is a problem during Save an Exception object will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>- Save will modify the <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> object's internal representation. As such, the user should acquire a write lock before calling save.</dd>
<dd>
- If the original pdf has a corrupt xref table (see HasRepairedXref), then it can not be saved using the e_incremental flag. </dd></dl>

</div>
</div>
<a class="anchor" id="af65f10be4f459a6f11227487bc9baa91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned char&gt; pdftron::PDF::PDFDoc::Save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3cd75b4f8acb377559a26f159bbbba46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::Save </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>out_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>out_buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Common::ProgressMonitor *&#160;</td>
          <td class="paramname"><em>progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the document to a memory buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_buf</td><td>a pointer to the buffer containing the serialized version of the document. (C++ Note) The buffer is owned by a document and the client doesn't need to do any initialization or cleanup. </td></tr>
    <tr><td class="paramname">out_buf_size</td><td>the size of the serialized document (i.e. out_buf) in bytes.</td></tr>
    <tr><td class="paramname">flags</td><td>- A bit field composed of an OR of SDFDoc::SaveOptions values. Note that this method ignores e_incremental flag. </td></tr>
    <tr><td class="paramname">progress</td><td>- A pointer to the progress interface. NULL if progress tracking is not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">-</td><td>if there is a problem during Save an Exception object will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>- Save will modify the <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> object's internal representation. As such, the user should acquire a write lock before calling save.</dd>
<dd>
- If the original pdf has a corrupt xref table (see HasRepairedXref), then it can not be saved using the e_incremental flag. </dd></dl>

</div>
</div>
<a class="anchor" id="a56fdd033e3575e5d4d4c204e2f88de62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::Save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepdftron.html#a15098075485d749c38929372ce2ca32d">UInt32</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the document to a stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The output stream where to write data. </td></tr>
    <tr><td class="paramname">flags</td><td>- A bit field composed of an OR of the SDFDoc::SaveOptions values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">-</td><td>if there is a problem during Save an Exception object will be thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>- Save will modify the <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html">PDFDoc</a> object's internal representation. As such, the user should acquire a write lock before calling save.</dd>
<dd>
- If the original pdf has a corrupt xref table (see HasRepairedXref), then it can not be saved using the e_incremental flag. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d3f96b2a8d7bdb46424c187ec9cf6a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::SaveCustomSignature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepdftron.html#a7bc90caf17b633a6832ec1e5162e1bc0">UChar</a> *&#160;</td>
          <td class="paramname"><em>in_signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>in_signature_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_p_d_f_1_1_digital_signature_field.html">DigitalSignatureField</a> &amp;&#160;</td>
          <td class="paramname"><em>in_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>in_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves a custom signature Contents to a document which has been prepared to receive it. No changes should be made to document in meantime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_signature</td><td>The signature Contents to write </td></tr>
    <tr><td class="paramname">in_signature_size</td><td>the size of the signature buffer </td></tr>
    <tr><td class="paramname">in_field</td><td>The signature field to which to write </td></tr>
    <tr><td class="paramname">in_path</td><td>The full path name to which the file is saved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">-</td><td>if there is a problem during Save an Exception object will be thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a5f3cec8331848194261e482d38a840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::SaveCustomSignature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepdftron.html#a7bc90caf17b633a6832ec1e5162e1bc0">UChar</a> *&#160;</td>
          <td class="paramname"><em>in_signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>in_signature_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_p_d_f_1_1_digital_signature_field.html">DigitalSignatureField</a> &amp;&#160;</td>
          <td class="paramname"><em>in_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_filters_1_1_filter.html">Filters::Filter</a> &amp;&#160;</td>
          <td class="paramname"><em>out_stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves a custom signature Contents to a document which has been prepared to receive it. No changes should be made to document in meantime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_signature</td><td>The signature Contents to write </td></tr>
    <tr><td class="paramname">in_signature_size</td><td>the size of the signature buffer </td></tr>
    <tr><td class="paramname">in_field</td><td>The signature field to which to write </td></tr>
    <tr><td class="paramname">out_stream</td><td>The output stream where to write data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">-</td><td>if there is a problem during Save an Exception object will be thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1bd2789345a1bfd62e2dec8f1bde483"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::SaveCustomSignature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepdftron.html#a7bc90caf17b633a6832ec1e5162e1bc0">UChar</a> *&#160;</td>
          <td class="paramname"><em>in_signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>in_signature_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_p_d_f_1_1_digital_signature_field.html">DigitalSignatureField</a> &amp;&#160;</td>
          <td class="paramname"><em>in_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepdftron.html#a7bc90caf17b633a6832ec1e5162e1bc0">UChar</a> *&amp;&#160;</td>
          <td class="paramname"><em>out_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>out_buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves a custom signature Contents to a document which has been prepared to receive it. No changes should be made to document in meantime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_signature</td><td>The signature Contents to write </td></tr>
    <tr><td class="paramname">in_signature_size</td><td>the size of the signature buffer </td></tr>
    <tr><td class="paramname">in_field</td><td>The signature field to which to write </td></tr>
    <tr><td class="paramname">out_buf</td><td>a pointer to the buffer containing the serialized version of the document. (C++ Note) The buffer is owned by a document and the client doesn't need to do any initialization or cleanup. </td></tr>
    <tr><td class="paramname">out_buf_size</td><td>the size of the serialized document (i.e. out_buf) in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">-</td><td>if there is a problem during Save an Exception object will be thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc7e2bd020ac646b8e629c75f7fdd4d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::SaveViewerOptimized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_u_string.html">UString</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_p_d_f_1_1_viewer_optimized_options.html">ViewerOptimizedOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies optimizations to improve viewing speed and saves the document to the specified file. The main optimizations used are linearization and embedding thumbnails for the first page and any complex pages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The full path name to which the file is saved. </td></tr>
    <tr><td class="paramname">opts</td><td>The optimization options</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>the file can't be opened for saving or if there is a problem during Save an Exception object will be thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acac2dd0afb5c44e721dca7878702a92b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::SaveViewerOptimized </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>out_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>out_buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_p_d_f_1_1_viewer_optimized_options.html">ViewerOptimizedOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies optimizations to improve viewing speed and saves the document to a memory buffer. The main optimizations used are linearization and embedding thumbnails for the first page and any other pages that are slow to render.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_buf</td><td>a pointer to the buffer containing the serialized version of the document. (C++ Note) The buffer is owned by a document and the client doesn't need to do any initialization or cleanup. </td></tr>
    <tr><td class="paramname">out_buf_size</td><td>the size of the serialized document (i.e. out_buf) in bytes. </td></tr>
    <tr><td class="paramname">opts</td><td>- The optimization options</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">-</td><td>if the file can't be opened for saving or if there is a problem during Save an Exception object will be thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7eaaf66bca8fcb4e7506b234ca05eba7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::SetOpenAction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_p_d_f_1_1_action.html">Action</a> &amp;&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classpdftron_1_1_p_d_f_1_1_action.html">Action</a> that will be triggered when the document is opened.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>A new <a class="el" href="classpdftron_1_1_p_d_f_1_1_action.html">Action</a> that will be triggered when the document is opened. An example of such action is a GoTo <a class="el" href="classpdftron_1_1_p_d_f_1_1_action.html">Action</a> that takes the user to a given location in the document. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a767edcf05ae465cce44a720a73163658"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::SetPageLabel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>page_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpdftron_1_1_p_d_f_1_1_page_label.html">PageLabel</a> &amp;&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attaches a label to a page. This establishes the numbering scheme for that page and all following it, until another page label is encountered. This label allows <a class="el" href="namespacepdftron_1_1_p_d_f.html">PDF</a> producers to define a page numbering system other than the default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_num</td><td>The number of the page to label. If page_num is less than 1 or greater than the number of pages in the document, the method does nothing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5ceed09f67451efc4599a4d97627ecf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::SetSecurityHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_s_d_f_1_1_security_handler.html">SDF::SecurityHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function sets a new SecurityHandler as the current security handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>new SecurityHandler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Setting a new security handler will not invalidate the access to the original file and will take effect during document <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ad486c18e60424b253164bfaa481a759b">Save()</a>.</dd>
<dd>
If the security handler is modified, document will perform a full save even if e_incremental was given as a flag in <a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#ad486c18e60424b253164bfaa481a759b">Save()</a> method. </dd></dl>

</div>
</div>
<a class="anchor" id="a0937b6595b48f8383dfe2f24d0a1c272"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::PDF::PDFDoc::TryLock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>milliseconds</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try locking the document, waiting no longer than specified number of milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>- max number of milliseconds to wait for the document to lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the document is locked for multi-threaded access, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a71a3f63b8585ddee9db9cde87335f1ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pdftron::PDF::PDFDoc::TryLockRead </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>milliseconds</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to obtain a read lock the document for &lt;milliseconds&gt; duration, and returns true if the lock was successfully acquired </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>duration to obtain a read lock for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the document is locked for multi-threaded access, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1bd0fee07a1ee1e3ce12b0b800d3f5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::Unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the lock from the document. </p>

</div>
</div>
<a class="anchor" id="aa61179c7ae9f00d9cc7c2e1ee67c5d79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdftron::PDF::PDFDoc::UnlockRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the read lock from the document. </p>

</div>
</div>
<a class="anchor" id="ade3fa14be9f5a511f141620f1946852e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpdftron_1_1_p_d_f_1_1_p_d_f_doc.html#acb06ed1ead06ee4cb4f383b3d655ee59">SignaturesVerificationStatus</a> pdftron::PDF::PDFDoc::VerifySignedDigitalSignatures </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpdftron_1_1_p_d_f_1_1_verification_options.html">VerificationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>in_opts</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempts to verify all signed cryptographic digital signatures in the document, ignoring unsigned signatures.</p>
<dl class="section return"><dt>Returns</dt><dd>an enumeration value representing the state of the document's signatures </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>PDF/<a class="el" href="_p_d_f_doc_8h_source.html">PDFDoc.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="footer">
<hr>
<small>
&copy 2001-2021 <a href="http://www.pdftron.com/">PDFTron Systems Inc.</a>
</small>
</div>
</body>
</html>
